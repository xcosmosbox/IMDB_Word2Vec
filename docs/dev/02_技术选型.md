# 技术选型文档

> 版本: v1.0  
> 更新日期: 2026-01-04  
> 对应架构文档: 《生成式推荐系统架构设计》全文

---

## 目录

1. [概述](#1-概述)
2. [技术选型总览](#2-技术选型总览)
3. [后端技术选型](#3-后端技术选型)
4. [前端技术选型](#4-前端技术选型)
5. [数据库技术选型](#5-数据库技术选型)
6. [算法框架选型](#6-算法框架选型)
7. [大模型接入选型](#7-大模型接入选型)
8. [基础设施选型](#8-基础设施选型)
9. [选型决策矩阵](#9-选型决策矩阵)

---

## 1. 概述

### 1.1 文档目的

本文档详细说明生成式推荐系统各模块的技术选型，包括选型理由、优劣势分析和与项目目标的匹配度评估。

### 1.2 选型原则

| 原则 | 说明 | 权重 |
|------|------|------|
| **生产成熟度** | 技术需经过大规模生产验证，非实验性技术 | 30% |
| **性能表现** | 满足万亿级数据、低延迟、高并发要求 | 25% |
| **生态完善度** | 社区活跃，文档完善，第三方集成丰富 | 20% |
| **团队熟悉度** | 团队有相关经验，降低学习成本 | 15% |
| **成本效益** | 开源优先，商业授权合理 | 10% |

### 1.3 架构约束

根据《生成式推荐系统架构设计》，技术选型需满足：

- **数据规模**: 万亿级交互日志 + 百亿级物品库
- **延迟要求**: P99 < 50ms（端到端推荐响应）
- **并发能力**: 百万 QPS（峰值）
- **冷启动**: 新用户/新物品 < 1小时内可推荐

---

## 2. 技术选型总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          技术栈全景图                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                           前端层                                     │   │
│  │  用户端: Vue 3 + Vite + Pinia + Axios                               │   │
│  │  管理端: Vue 3 + Ant Design Vue + ECharts                           │   │
│  │  可视化: ECharts + Three.js (3D 展示)                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    ↕                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                           后端层                                     │   │
│  │  HTTP 框架: Gin (Go)                                                │   │
│  │  RPC 框架: gRPC + Protobuf                                          │   │
│  │  服务网格: Istio                                                    │   │
│  │  消息队列: Kafka                                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    ↕                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          数据层                                      │   │
│  │  主数据库: PostgreSQL + pgvector                                     │   │
│  │  向量数据库: Milvus                                                  │   │
│  │  缓存: Redis Cluster                                                │   │
│  │  OLAP: ClickHouse                                                   │   │
│  │  对象存储: MinIO                                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    ↕                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          算法层                                      │   │
│  │  训练框架: PyTorch + DeepSpeed                                       │   │
│  │  推理框架: TensorRT + Triton Inference Server                        │   │
│  │  特征工程: Apache Spark                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    ↕                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         基础设施层                                    │   │
│  │  容器编排: Kubernetes                                                │   │
│  │  CI/CD: GitLab CI + ArgoCD                                          │   │
│  │  监控: Prometheus + Grafana + Jaeger                                 │   │
│  │  日志: ELK Stack (Elasticsearch + Logstash + Kibana)                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 后端技术选型

### 3.1 开发语言: Go

#### 选型理由

| 维度 | Go 语言优势 | 与项目目标匹配 |
|------|------------|---------------|
| **并发性能** | goroutine 轻量级协程，可轻松支持百万并发 | ✅ 满足百万 QPS 要求 |
| **编译效率** | 快速编译，静态链接，部署简单 | ✅ 快速迭代部署 |
| **内存效率** | GC 优化，内存占用低 | ✅ 降低资源成本 |
| **生态成熟** | 微服务生态完善（K8s、Docker 均 Go 编写） | ✅ 与基础设施天然集成 |
| **学习曲线** | 语法简洁，上手快 | ✅ 团队快速上手 |

#### 备选方案对比

| 语言 | 并发性能 | 开发效率 | 生态成熟度 | 推荐指数 |
|------|---------|---------|-----------|---------|
| **Go** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ **推荐** |
| Rust | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | 学习成本高 |
| Java | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 内存占用高 |
| Python | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 性能不足 |

### 3.2 HTTP 框架: Gin

#### 选型理由

```go
// Gin 示例：高性能路由
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    r := gin.New()
    
    // 中间件：请求日志、恢复、限流
    r.Use(gin.Logger(), gin.Recovery(), RateLimiter())
    
    // 推荐服务路由组
    recommend := r.Group("/api/v1/recommend")
    {
        recommend.POST("/generate", GenerateHandler)
        recommend.GET("/user/:uid", UserRecommendHandler)
        recommend.POST("/feedback", FeedbackHandler)
    }
    
    r.Run(":8080")
}
```

| 特性 | Gin 优势 |
|------|---------|
| **性能** | 基于 httprouter，性能最优的 Go HTTP 框架之一 |
| **中间件** | 丰富的中间件生态（认证、限流、CORS、日志等） |
| **验证** | 内置 binding 验证，支持结构体标签验证 |
| **文档** | 易集成 Swagger 自动生成 API 文档 |

#### 备选方案对比

| 框架 | 性能 | 易用性 | 生态 | 推荐指数 |
|------|-----|-------|------|---------|
| **Gin** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ **推荐** |
| Echo | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 备选 |
| Fiber | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 生态偏弱 |
| Chi | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 功能偏少 |

### 3.3 RPC 框架: gRPC

#### 选型理由

```protobuf
// recommend.proto - 推荐服务 Protobuf 定义
syntax = "proto3";

package recommend.v1;

service RecommendService {
    // 生成推荐
    rpc Generate(GenerateRequest) returns (GenerateResponse);
    
    // 流式推荐（实时场景）
    rpc StreamGenerate(GenerateRequest) returns (stream RecommendItem);
    
    // 批量推荐
    rpc BatchGenerate(BatchGenerateRequest) returns (BatchGenerateResponse);
}

message GenerateRequest {
    string user_id = 1;
    int32 count = 2;
    repeated string context_features = 3;
}

message RecommendItem {
    string item_id = 1;
    float score = 2;
    repeated int32 semantic_ids = 3;
}
```

| 特性 | gRPC 优势 |
|------|----------|
| **性能** | HTTP/2 多路复用 + Protobuf 二进制序列化 |
| **类型安全** | 强类型 IDL，编译时检查 |
| **流式支持** | 原生支持双向流，适合实时推荐 |
| **多语言** | Go、Python、Java 等多语言支持 |

### 3.4 消息队列: Kafka

#### 选型理由

| 维度 | Kafka 优势 | 应用场景 |
|------|-----------|---------|
| **高吞吐** | 百万级 TPS | 用户行为日志采集 |
| **持久化** | 消息持久化，支持回溯 | 训练数据收集 |
| **分区** | 水平扩展能力强 | 多业务隔离 |
| **生态** | Kafka Connect、Kafka Streams | 数据管道集成 |

```yaml
# Kafka 配置示例
kafka:
  brokers:
    - kafka-0:9092
    - kafka-1:9092
    - kafka-2:9092
  topics:
    user_events:
      partitions: 128
      replication: 3
      retention: 7d
    recommendation_logs:
      partitions: 64
      replication: 3
      retention: 30d
```

#### 备选方案对比

| 消息队列 | 吞吐量 | 延迟 | 持久化 | 推荐指数 |
|---------|-------|-----|-------|---------|
| **Kafka** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ **推荐** |
| Pulsar | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 运维复杂 |
| RabbitMQ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 吞吐不足 |
| RocketMQ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 备选 |

### 3.5 服务网格: Istio

#### 选型理由

```yaml
# Istio VirtualService 配置示例
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: recommend-service
spec:
  hosts:
    - recommend-service
  http:
    - match:
        - headers:
            x-canary:
              exact: "true"
      route:
        - destination:
            host: recommend-service
            subset: canary
          weight: 100
    - route:
        - destination:
            host: recommend-service
            subset: stable
          weight: 95
        - destination:
            host: recommend-service
            subset: canary
          weight: 5
```

| 特性 | Istio 优势 |
|------|-----------|
| **流量管理** | 灰度发布、A/B 测试、流量镜像 |
| **可观测性** | 自动注入追踪、指标收集 |
| **安全** | mTLS 加密、细粒度访问控制 |
| **弹性** | 熔断、重试、超时配置 |

---

## 4. 前端技术选型

### 4.1 框架: Vue 3 + Vite

#### 选型理由

| 维度 | Vue 3 优势 |
|------|-----------|
| **性能** | Composition API、Tree-shaking、更小的包体积 |
| **开发体验** | Vite 热更新极快，开发效率高 |
| **生态** | Vue Router、Pinia、丰富的 UI 组件库 |
| **学习成本** | 渐进式框架，上手简单 |

```typescript
// Vue 3 Composition API 示例
import { ref, computed, onMounted } from 'vue'
import { useRecommendStore } from '@/stores/recommend'

export function useRecommendations(userId: string) {
  const store = useRecommendStore()
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const recommendations = computed(() => store.getRecommendations(userId))
  
  async function fetchRecommendations() {
    loading.value = true
    try {
      await store.fetchRecommendations(userId)
    } catch (e) {
      error.value = e.message
    } finally {
      loading.value = false
    }
  }
  
  onMounted(fetchRecommendations)
  
  return {
    recommendations,
    loading,
    error,
    refresh: fetchRecommendations,
  }
}
```

#### 备选方案对比

| 框架 | 性能 | 生态 | 学习成本 | 推荐指数 |
|------|-----|------|---------|---------|
| **Vue 3** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ **推荐** |
| React | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 备选 |
| Svelte | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | 生态偏弱 |

### 4.2 UI 组件库

#### 用户端: 自定义组件库

```typescript
// 推荐卡片组件示例
<template>
  <div class="recommend-card" @click="handleClick">
    <div class="card-image">
      <img :src="item.cover" :alt="item.title" loading="lazy" />
      <div class="card-badge" v-if="item.isNew">NEW</div>
    </div>
    <div class="card-content">
      <h3 class="card-title">{{ item.title }}</h3>
      <p class="card-desc">{{ item.description }}</p>
      <div class="card-meta">
        <span class="card-score">{{ formatScore(item.score) }}</span>
        <span class="card-reason">{{ item.reason }}</span>
      </div>
    </div>
  </div>
</template>

<style scoped>
.recommend-card {
  /* 现代卡片设计 */
  border-radius: 12px;
  overflow: hidden;
  transition: transform 0.2s, box-shadow 0.2s;
  
  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
  }
}
</style>
```

#### 管理端: Ant Design Vue

| 特性 | Ant Design Vue 优势 |
|------|-------------------|
| **企业级** | 专为后台管理系统设计 |
| **组件丰富** | 表格、表单、图表等完整组件 |
| **主题定制** | 支持 CSS 变量主题定制 |
| **国际化** | 内置国际化支持 |

### 4.3 状态管理: Pinia

```typescript
// stores/recommend.ts
import { defineStore } from 'pinia'
import { recommendApi } from '@/api'

interface RecommendState {
  items: Record<string, RecommendItem[]>
  loading: boolean
  error: string | null
}

export const useRecommendStore = defineStore('recommend', {
  state: (): RecommendState => ({
    items: {},
    loading: false,
    error: null,
  }),
  
  getters: {
    getRecommendations: (state) => (userId: string) => {
      return state.items[userId] || []
    },
  },
  
  actions: {
    async fetchRecommendations(userId: string, count = 20) {
      this.loading = true
      try {
        const response = await recommendApi.generate(userId, count)
        this.items[userId] = response.items
      } catch (e) {
        this.error = e.message
      } finally {
        this.loading = false
      }
    },
  },
})
```

### 4.4 可视化: ECharts + Three.js

| 场景 | 技术选型 | 说明 |
|------|---------|------|
| **图表** | ECharts | 推荐效果仪表盘、数据分析 |
| **3D 可视化** | Three.js | 嵌入空间可视化、物品关系图 |
| **实时监控** | ECharts + WebSocket | 实时 QPS、延迟监控 |

---

## 5. 数据库技术选型

### 5.1 主数据库: PostgreSQL + pgvector

#### 选型理由

| 维度 | PostgreSQL 优势 |
|------|----------------|
| **成熟稳定** | 30+ 年历史，久经考验 |
| **扩展性** | pgvector 扩展支持向量搜索 |
| **SQL 完整** | 完整 SQL 支持，复杂查询友好 |
| **开源免费** | 无商业授权限制 |

```sql
-- PostgreSQL + pgvector 示例
-- 创建物品表（含向量）
CREATE TABLE items (
    id BIGSERIAL PRIMARY KEY,
    item_id VARCHAR(64) UNIQUE NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    category_path VARCHAR(256),
    embedding vector(256),  -- pgvector 向量类型
    semantic_ids INTEGER[3],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建向量索引（IVFFlat）
CREATE INDEX idx_items_embedding ON items 
USING ivfflat (embedding vector_cosine_ops) 
WITH (lists = 1000);

-- 向量相似度查询
SELECT item_id, title, 
       1 - (embedding <=> $1) AS similarity
FROM items
WHERE embedding <=> $1 < 0.5
ORDER BY embedding <=> $1
LIMIT 50;
```

#### 数据模型设计

```sql
-- 用户表
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(64) UNIQUE NOT NULL,
    profile JSONB,
    preferences JSONB,
    embedding vector(256),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    last_active_at TIMESTAMPTZ
);

-- 用户行为表（分区表）
CREATE TABLE user_events (
    id BIGSERIAL,
    user_id VARCHAR(64) NOT NULL,
    event_type VARCHAR(32) NOT NULL,
    item_id VARCHAR(64) NOT NULL,
    context JSONB,
    timestamp TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (id, timestamp)
) PARTITION BY RANGE (timestamp);

-- 按月分区
CREATE TABLE user_events_2026_01 PARTITION OF user_events
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');
```

### 5.2 向量数据库: Milvus

#### 选型理由

| 维度 | Milvus 优势 |
|------|-----------|
| **专业向量搜索** | 专为向量检索设计，性能最优 |
| **海量数据** | 支持百亿级向量 |
| **多索引** | IVF_FLAT、HNSW、ANNOY 等多种索引 |
| **云原生** | Kubernetes 原生部署 |

```python
# Milvus 使用示例
from pymilvus import Collection, connections

# 连接 Milvus
connections.connect(host='milvus-service', port='19530')

# 创建集合
collection = Collection(
    name="item_embeddings",
    schema=CollectionSchema([
        FieldSchema(name="item_id", dtype=DataType.VARCHAR, max_length=64, is_primary=True),
        FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=256),
        FieldSchema(name="semantic_l1", dtype=DataType.INT32),
        FieldSchema(name="semantic_l2", dtype=DataType.INT32),
    ])
)

# 创建 HNSW 索引
collection.create_index(
    field_name="embedding",
    index_params={
        "index_type": "HNSW",
        "metric_type": "IP",  # 内积
        "params": {"M": 16, "efConstruction": 200}
    }
)

# 向量搜索
results = collection.search(
    data=[query_embedding],
    anns_field="embedding",
    param={"metric_type": "IP", "params": {"ef": 100}},
    limit=50,
    output_fields=["item_id", "semantic_l1"]
)
```

#### Milvus vs pgvector 对比

| 维度 | Milvus | pgvector |
|------|--------|----------|
| **向量规模** | 百亿级 | 千万级 |
| **搜索延迟** | < 10ms | < 50ms |
| **功能丰富度** | 专业 | 基础 |
| **运维复杂度** | 高 | 低 |
| **推荐场景** | 高性能向量检索 | 中小规模、与 PG 集成 |

**决策**: 两者并用
- **Milvus**: 用于实时推荐的高性能向量检索
- **pgvector**: 用于管理后台的向量查询和数据分析

### 5.3 缓存: Redis Cluster

#### 选型理由

| 维度 | Redis Cluster 优势 |
|------|-------------------|
| **高性能** | 内存存储，微秒级延迟 |
| **数据结构** | 丰富的数据结构（String、Hash、ZSet 等） |
| **分布式** | 原生分布式，支持水平扩展 |
| **持久化** | RDB + AOF 双重持久化 |

```go
// Redis 使用场景示例
package cache

import (
    "context"
    "time"
    "github.com/redis/go-redis/v9"
)

type RecommendCache struct {
    client *redis.ClusterClient
}

// 缓存用户推荐结果
func (c *RecommendCache) SetUserRecommends(ctx context.Context, userID string, items []RecommendItem, ttl time.Duration) error {
    key := fmt.Sprintf("rec:user:%s", userID)
    data, _ := json.Marshal(items)
    return c.client.Set(ctx, key, data, ttl).Err()
}

// 缓存热门物品
func (c *RecommendCache) SetHotItems(ctx context.Context, category string, items []string) error {
    key := fmt.Sprintf("hot:items:%s", category)
    return c.client.ZAdd(ctx, key, 
        redis.Z{Score: float64(time.Now().Unix()), Member: items[0]},
        // ...
    ).Err()
}

// 用户特征缓存（Hash）
func (c *RecommendCache) SetUserFeatures(ctx context.Context, userID string, features map[string]string) error {
    key := fmt.Sprintf("user:features:%s", userID)
    return c.client.HSet(ctx, key, features).Err()
}
```

### 5.4 OLAP: ClickHouse

#### 选型理由

| 维度 | ClickHouse 优势 |
|------|----------------|
| **查询性能** | 列式存储，聚合查询极快 |
| **压缩率** | 高压缩率，存储成本低 |
| **实时写入** | 支持高吞吐实时写入 |
| **SQL 兼容** | 标准 SQL 语法 |

```sql
-- ClickHouse 表结构示例
CREATE TABLE recommendation_logs (
    event_id UUID DEFAULT generateUUIDv4(),
    user_id String,
    request_id String,
    recommended_items Array(String),
    scores Array(Float32),
    algorithm_version String,
    latency_ms UInt32,
    timestamp DateTime64(3) DEFAULT now64(3)
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (user_id, timestamp)
TTL timestamp + INTERVAL 90 DAY;

-- 实时分析查询
SELECT 
    toStartOfHour(timestamp) AS hour,
    count() AS request_count,
    avg(latency_ms) AS avg_latency,
    quantile(0.99)(latency_ms) AS p99_latency
FROM recommendation_logs
WHERE timestamp >= now() - INTERVAL 24 HOUR
GROUP BY hour
ORDER BY hour;
```

### 5.5 对象存储: MinIO

| 维度 | MinIO 优势 |
|------|-----------|
| **S3 兼容** | 完全兼容 AWS S3 API |
| **高性能** | 专为 AI/ML 工作负载优化 |
| **开源** | Apache 2.0 许可证 |
| **部署灵活** | 支持单机/分布式部署 |

**存储内容**:
- 模型检查点
- 训练数据集
- 物品多媒体资源
- 日志归档

---

## 6. 算法框架选型

### 6.1 训练框架: PyTorch + DeepSpeed

#### 选型理由

| 维度 | PyTorch + DeepSpeed 优势 |
|------|-------------------------|
| **灵活性** | 动态图，调试友好 |
| **分布式训练** | DeepSpeed ZeRO 系列优化 |
| **大模型支持** | 支持万亿参数模型训练 |
| **生态** | Hugging Face、NVIDIA 深度集成 |

```python
# DeepSpeed 配置示例
deepspeed_config = {
    "train_batch_size": 1024,
    "gradient_accumulation_steps": 4,
    "fp16": {
        "enabled": True,
        "loss_scale": 0,
        "loss_scale_window": 1000,
    },
    "zero_optimization": {
        "stage": 2,
        "offload_optimizer": {"device": "cpu"},
        "contiguous_gradients": True,
    },
    "optimizer": {
        "type": "AdamW",
        "params": {
            "lr": 1e-4,
            "betas": [0.9, 0.999],
            "weight_decay": 0.01,
        }
    },
}
```

### 6.2 推理框架: TensorRT + Triton

#### 选型理由

| 维度 | TensorRT + Triton 优势 |
|------|----------------------|
| **GPU 优化** | NVIDIA 官方优化，性能极致 |
| **低延迟** | 算子融合、量化、图优化 |
| **高吞吐** | 动态 batching，最大化 GPU 利用率 |
| **多模型** | 统一服务多个模型 |

```python
# TensorRT 优化示例
import tensorrt as trt

def build_engine(onnx_path, engine_path):
    logger = trt.Logger(trt.Logger.WARNING)
    builder = trt.Builder(logger)
    network = builder.create_network(
        1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)
    )
    parser = trt.OnnxParser(network, logger)
    
    # 解析 ONNX 模型
    with open(onnx_path, 'rb') as f:
        parser.parse(f.read())
    
    # 配置优化
    config = builder.create_builder_config()
    config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, 1 << 30)  # 1GB
    config.set_flag(trt.BuilderFlag.FP16)  # FP16 量化
    
    # 构建引擎
    engine = builder.build_serialized_network(network, config)
    with open(engine_path, 'wb') as f:
        f.write(engine)
```

```yaml
# Triton 模型配置
name: "ugt_recommend"
platform: "tensorrt_plan"
max_batch_size: 64

input [
  {
    name: "user_sequence"
    data_type: TYPE_INT64
    dims: [ -1, 1024 ]  # 动态序列长度
  }
]

output [
  {
    name: "recommendations"
    data_type: TYPE_INT64
    dims: [ -1, 50 ]  # Top-50 推荐
  },
  {
    name: "scores"
    data_type: TYPE_FP32
    dims: [ -1, 50 ]
  }
]

dynamic_batching {
  preferred_batch_size: [ 8, 16, 32, 64 ]
  max_queue_delay_microseconds: 100
}

instance_group [
  {
    count: 2
    kind: KIND_GPU
    gpus: [ 0, 1 ]
  }
]
```

### 6.3 特征工程: Apache Spark

| 维度 | Spark 优势 |
|------|-----------|
| **大规模处理** | 支持 PB 级数据处理 |
| **统一引擎** | SQL、流处理、ML 统一 |
| **生态丰富** | Delta Lake、MLlib 等 |
| **成熟稳定** | 大厂广泛使用 |

---

## 7. 大模型接入选型

### 7.1 LLM Provider 对比

| Provider | 模型 | 优势 | 劣势 | 推荐场景 |
|----------|------|------|------|---------|
| **OpenAI** | GPT-4/GPT-4o | 能力最强 | 成本高、网络延迟 | 冷启动语义理解 |
| **Anthropic** | Claude 3 | 长上下文、安全性好 | 成本较高 | 用户画像生成 |
| **本地部署** | Llama 3 / Qwen | 成本低、延迟低 | 能力偏弱 | 批量处理、隐私敏感 |

### 7.2 推荐方案: 混合策略

```python
# LLM 路由策略
class LLMRouter:
    """
    LLM 请求路由器
    
    根据场景自动选择最合适的 LLM
    """
    
    def __init__(self):
        self.openai = OpenAIClient()
        self.local = LocalLlamaClient()
        
    async def route(self, task_type: str, content: str) -> str:
        """
        路由决策:
        - 冷启动语义理解: OpenAI GPT-4 (质量优先)
        - 批量特征提取: 本地 Llama (成本优先)
        - 实时推荐解释: 本地 Llama (延迟优先)
        """
        if task_type == "cold_start_understanding":
            return await self.openai.complete(content)
        elif task_type == "batch_feature_extraction":
            return await self.local.complete(content)
        elif task_type == "realtime_explanation":
            return await self.local.complete(content, max_tokens=100)
        else:
            return await self.local.complete(content)
```

---

## 8. 基础设施选型

### 8.1 容器编排: Kubernetes

| 维度 | K8s 优势 |
|------|---------|
| **行业标准** | 事实上的容器编排标准 |
| **自动化** | 自动扩缩容、故障恢复 |
| **生态** | Helm、Operator 生态丰富 |
| **多云** | 支持多云/混合云部署 |

### 8.2 CI/CD: GitLab CI + ArgoCD

```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

test:
  stage: test
  script:
    - go test ./... -v -cover -coverprofile=coverage.out
    - go tool cover -func=coverage.out | grep total | awk '{print $3}'
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'

build:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

deploy:
  stage: deploy
  script:
    - argocd app sync recommend-service --revision $CI_COMMIT_SHA
  only:
    - main
```

### 8.3 监控: Prometheus + Grafana + Jaeger

| 工具 | 用途 |
|------|------|
| **Prometheus** | 指标收集、告警规则 |
| **Grafana** | 可视化仪表盘 |
| **Jaeger** | 分布式追踪 |
| **Alertmanager** | 告警通知 |

---

## 9. 选型决策矩阵

### 9.1 综合评分

| 模块 | 选型 | 成熟度 | 性能 | 生态 | 成本 | 综合分 |
|------|------|--------|------|------|------|--------|
| 后端语言 | Go | 5 | 5 | 5 | 5 | **5.0** |
| HTTP 框架 | Gin | 5 | 5 | 5 | 5 | **5.0** |
| RPC 框架 | gRPC | 5 | 5 | 4 | 5 | **4.7** |
| 消息队列 | Kafka | 5 | 5 | 5 | 4 | **4.7** |
| 前端框架 | Vue 3 | 5 | 5 | 4 | 5 | **4.7** |
| 主数据库 | PostgreSQL | 5 | 4 | 5 | 5 | **4.7** |
| 向量数据库 | Milvus | 4 | 5 | 4 | 4 | **4.2** |
| 缓存 | Redis | 5 | 5 | 5 | 4 | **4.7** |
| OLAP | ClickHouse | 5 | 5 | 4 | 5 | **4.7** |
| 训练框架 | PyTorch | 5 | 5 | 5 | 5 | **5.0** |
| 推理框架 | TensorRT | 4 | 5 | 4 | 4 | **4.2** |
| 容器编排 | K8s | 5 | 5 | 5 | 4 | **4.7** |

### 9.2 技术风险评估

| 技术 | 风险等级 | 风险描述 | 缓解措施 |
|------|---------|---------|---------|
| Milvus | 中 | 运维复杂度高 | 使用云服务托管版 |
| TensorRT | 中 | 模型转换可能有兼容性问题 | 提前验证 POC |
| Istio | 中 | 性能开销、学习成本 | 渐进式引入 |
| 本地 LLM | 低 | 效果可能不及商业模型 | 关键场景使用 OpenAI |

### 9.3 依赖版本锁定

```yaml
# 核心依赖版本
backend:
  go: "1.22"
  gin: "1.9.1"
  grpc: "1.62.0"
  kafka: "3.6.0"

frontend:
  vue: "3.4.0"
  vite: "5.0.0"
  pinia: "2.1.0"

database:
  postgresql: "16.0"
  milvus: "2.4.0"
  redis: "7.2"
  clickhouse: "24.1"

ml:
  pytorch: "2.2.0"
  deepspeed: "0.13.0"
  tensorrt: "8.6"
  triton: "24.01"

infrastructure:
  kubernetes: "1.29"
  istio: "1.20"
  prometheus: "2.49"
  grafana: "10.3"
```

---

> **文档版本历史**
> - v1.0 (2026-01-04): 初始版本，完整技术选型说明

