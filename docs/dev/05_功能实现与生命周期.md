# 功能实现与全生命周期指导文档

> 版本: v1.0  
> 更新日期: 2026-01-04  
> 对应架构文档: 《生成式推荐系统架构设计》

---

## 目录

1. [概述](#1-概述)
2. [核心功能实现](#2-核心功能实现)
3. [开发规范](#3-开发规范)
4. [测试方案](#4-测试方案)
5. [部署方案](#5-部署方案)
6. [运维方案](#6-运维方案)
7. [上线方案](#7-上线方案)

---

## 1. 概述

### 1.1 文档目的

本文档提供生成式推荐系统从开发到运维的全生命周期指导，包括核心功能实现、开发规范、测试策略、部署流程、运维监控和上线方案。

### 1.2 生命周期总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         软件开发生命周期                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐      │
│  │  开发   │──→│  测试   │──→│  部署   │──→│  运维   │──→│  迭代   │      │
│  │ Develop │   │  Test   │   │ Deploy  │   │ Operate │   │ Iterate │      │
│  └─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘      │
│       │             │             │             │             │            │
│       ▼             ▼             ▼             ▼             ▼            │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐      │
│  │代码开发 │   │单元测试 │   │CI/CD   │   │监控告警 │   │需求分析 │      │
│  │代码审查 │   │集成测试 │   │灰度发布 │   │日志分析 │   │版本规划 │      │
│  │分支管理 │   │性能测试 │   │全量发布 │   │应急预案 │   │效果评估 │      │
│  └─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心功能实现

### 2.1 推荐生成流程

#### 2.1.1 核心逻辑

```go
// internal/service/recommend/generate.go
package recommend

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// GenerateRecommendations 生成推荐的核心逻辑
func (s *RecommendService) GenerateRecommendations(
    ctx context.Context,
    req *GenerateRequest,
) (*GenerateResponse, error) {
    // 1. 开始链路追踪
    ctx, span := otel.Tracer("recommend-service").Start(ctx, "GenerateRecommendations")
    defer span.End()
    
    startTime := time.Now()
    
    // 2. 参数校验
    if err := s.validateRequest(req); err != nil {
        span.SetAttributes(attribute.String("error", err.Error()))
        return nil, NewValidationError(err)
    }
    
    // 3. 尝试从缓存获取
    cacheKey := s.buildCacheKey(req)
    if cached, ok := s.tryGetFromCache(ctx, cacheKey); ok {
        span.SetAttributes(attribute.Bool("cache_hit", true))
        return cached, nil
    }
    span.SetAttributes(attribute.Bool("cache_hit", false))
    
    // 4. 获取用户特征 (并行获取)
    userFeatures, itemCandidates, err := s.fetchFeaturesParallel(ctx, req)
    if err != nil {
        // 降级：使用默认特征
        userFeatures = s.getDefaultUserFeatures()
        s.metrics.IncrCounter("feature_fetch_fallback", 1)
    }
    
    // 5. 构建推理请求
    inferenceReq := s.buildInferenceRequest(req, userFeatures, itemCandidates)
    
    // 6. 调用模型推理
    inferenceCtx, cancel := context.WithTimeout(ctx, s.config.InferenceTimeout)
    defer cancel()
    
    inferenceResp, err := s.inferenceClient.Infer(inferenceCtx, inferenceReq)
    if err != nil {
        span.SetAttributes(attribute.String("inference_error", err.Error()))
        
        // 降级策略
        if s.config.EnableFallback {
            return s.fallbackRecommend(ctx, req)
        }
        return nil, NewInferenceError(err)
    }
    
    // 7. 后处理
    // 7.1 过滤已曝光物品
    filteredItems := s.filterExposedItems(ctx, req.UserID, inferenceResp.Items)
    
    // 7.2 业务规则过滤
    filteredItems = s.applyBusinessRules(ctx, req, filteredItems)
    
    // 7.3 多样性增强
    if s.config.DiversityEnabled {
        filteredItems = s.enhanceDiversity(filteredItems, req.Count)
    }
    
    // 8. 补充物品详情
    enrichedItems, err := s.enrichItems(ctx, filteredItems)
    if err != nil {
        // 部分失败不阻断流程
        s.logger.Warnf("failed to enrich some items: %v", err)
    }
    
    // 9. 构建响应
    response := &GenerateResponse{
        RequestID: generateRequestID(),
        Items:     enrichedItems,
        Metadata: &ResponseMetadata{
            AlgorithmVersion: inferenceResp.ModelVersion,
            LatencyMs:        int32(time.Since(startTime).Milliseconds()),
            IsFallback:       false,
            TraceID:          span.SpanContext().TraceID().String(),
        },
    }
    
    // 10. 异步操作
    go func() {
        // 写入缓存
        s.setToCache(context.Background(), cacheKey, response)
        
        // 记录推荐日志
        s.logRecommendation(req, response)
        
        // 更新曝光记录
        s.recordExposure(req.UserID, enrichedItems)
    }()
    
    // 11. 记录指标
    s.recordMetrics(req, response, startTime)
    
    return response, nil
}

// fetchFeaturesParallel 并行获取特征
func (s *RecommendService) fetchFeaturesParallel(
    ctx context.Context,
    req *GenerateRequest,
) (*UserFeatures, []string, error) {
    var wg sync.WaitGroup
    var mu sync.Mutex
    var errs []error
    
    var userFeatures *UserFeatures
    var itemCandidates []string
    
    // 并行获取用户特征
    wg.Add(1)
    go func() {
        defer wg.Done()
        features, err := s.featureService.GetUserFeatures(ctx, req.UserID)
        mu.Lock()
        defer mu.Unlock()
        if err != nil {
            errs = append(errs, err)
        } else {
            userFeatures = features
        }
    }()
    
    // 并行获取候选物品
    wg.Add(1)
    go func() {
        defer wg.Done()
        candidates, err := s.getCandidates(ctx, req)
        mu.Lock()
        defer mu.Unlock()
        if err != nil {
            errs = append(errs, err)
        } else {
            itemCandidates = candidates
        }
    }()
    
    wg.Wait()
    
    if len(errs) > 0 {
        return userFeatures, itemCandidates, errs[0]
    }
    
    return userFeatures, itemCandidates, nil
}

// enhanceDiversity 多样性增强
func (s *RecommendService) enhanceDiversity(items []*RecommendItem, targetCount int) []*RecommendItem {
    if len(items) <= targetCount {
        return items
    }
    
    result := make([]*RecommendItem, 0, targetCount)
    categoryCount := make(map[string]int)
    brandCount := make(map[string]int)
    
    maxCategoryItems := s.config.MaxCategoryItems  // 默认 3
    maxBrandItems := s.config.MaxBrandItems        // 默认 2
    
    for _, item := range items {
        if len(result) >= targetCount {
            break
        }
        
        // 检查类目限制
        if categoryCount[item.Category] >= maxCategoryItems {
            continue
        }
        
        // 检查品牌限制
        if item.Brand != "" && brandCount[item.Brand] >= maxBrandItems {
            continue
        }
        
        result = append(result, item)
        categoryCount[item.Category]++
        if item.Brand != "" {
            brandCount[item.Brand]++
        }
    }
    
    // 如果多样性过滤后数量不足，补充剩余物品
    if len(result) < targetCount {
        for _, item := range items {
            if len(result) >= targetCount {
                break
            }
            
            found := false
            for _, r := range result {
                if r.ItemID == item.ItemID {
                    found = true
                    break
                }
            }
            
            if !found {
                result = append(result, item)
            }
        }
    }
    
    return result
}

// fallbackRecommend 降级推荐
func (s *RecommendService) fallbackRecommend(
    ctx context.Context,
    req *GenerateRequest,
) (*GenerateResponse, error) {
    s.metrics.IncrCounter("fallback_triggered", 1)
    
    // 策略 1: 返回热门物品
    hotItems, err := s.cache.GetHotItems(ctx, req.SceneID, int(req.Count))
    if err == nil && len(hotItems) > 0 {
        return &GenerateResponse{
            RequestID: generateRequestID(),
            Items:     hotItems,
            Metadata: &ResponseMetadata{
                IsFallback:     true,
                FallbackReason: "hot_items",
            },
        }, nil
    }
    
    // 策略 2: 返回用户历史偏好相关物品
    historyItems, err := s.getUserHistoryRecommend(ctx, req.UserID, int(req.Count))
    if err == nil && len(historyItems) > 0 {
        return &GenerateResponse{
            RequestID: generateRequestID(),
            Items:     historyItems,
            Metadata: &ResponseMetadata{
                IsFallback:     true,
                FallbackReason: "history_based",
            },
        }, nil
    }
    
    // 策略 3: 返回兜底物品
    fallbackItems := s.getFallbackItems(int(req.Count))
    return &GenerateResponse{
        RequestID: generateRequestID(),
        Items:     fallbackItems,
        Metadata: &ResponseMetadata{
            IsFallback:     true,
            FallbackReason: "default_items",
        },
    }, nil
}
```

#### 2.1.2 异常处理

```go
// internal/service/recommend/errors.go
package recommend

import (
    "fmt"
)

// 错误类型定义
type ErrorCode int

const (
    ErrCodeUnknown ErrorCode = iota + 50000
    ErrCodeValidation
    ErrCodeInference
    ErrCodeFeature
    ErrCodeCache
    ErrCodeDatabase
)

// RecommendError 推荐服务错误
type RecommendError struct {
    Code    ErrorCode
    Message string
    Cause   error
}

func (e *RecommendError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%d] %s: %v", e.Code, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}

func (e *RecommendError) Unwrap() error {
    return e.Cause
}

// 错误构造函数
func NewValidationError(err error) *RecommendError {
    return &RecommendError{
        Code:    ErrCodeValidation,
        Message: "请求参数错误",
        Cause:   err,
    }
}

func NewInferenceError(err error) *RecommendError {
    return &RecommendError{
        Code:    ErrCodeInference,
        Message: "推理服务异常",
        Cause:   err,
    }
}

// 错误处理中间件
func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()
        
        if len(c.Errors) > 0 {
            err := c.Errors.Last().Err
            
            var recErr *RecommendError
            if errors.As(err, &recErr) {
                c.JSON(getHTTPStatus(recErr.Code), gin.H{
                    "code":    int(recErr.Code),
                    "message": recErr.Message,
                    "data":    nil,
                })
                return
            }
            
            // 未知错误
            c.JSON(500, gin.H{
                "code":    50000,
                "message": "服务内部错误",
                "data":    nil,
            })
        }
    }
}
```

### 2.2 冷启动处理

```go
// internal/service/coldstart/processor.go
package coldstart

import (
    "context"
    "encoding/json"
)

// ItemProcessor 新物品处理器
type ItemProcessor struct {
    llmClient       LLMClient
    semanticEncoder SemanticEncoder
    vectorStore     VectorStore
    itemRepo        ItemRepository
}

// ProcessNewItem 处理新物品
func (p *ItemProcessor) ProcessNewItem(ctx context.Context, item *Item) (*ProcessResult, error) {
    // 1. LLM 语义理解
    understanding, err := p.understandItem(ctx, item)
    if err != nil {
        // 降级：使用规则匹配
        understanding = p.ruleBasedUnderstanding(item)
    }
    
    // 2. 生成语义 ID
    semanticIDs, err := p.semanticEncoder.Encode(ctx, item, understanding)
    if err != nil {
        return nil, fmt.Errorf("failed to encode semantic IDs: %w", err)
    }
    
    // 3. 生成初始嵌入
    embedding, err := p.generateInitialEmbedding(ctx, item, understanding)
    if err != nil {
        return nil, fmt.Errorf("failed to generate embedding: %w", err)
    }
    
    // 4. 找相似物品
    similarItems, err := p.vectorStore.SearchSimilar(ctx, embedding, 10)
    if err != nil {
        // 非关键错误，记录但不阻断
        log.Warnf("failed to find similar items: %v", err)
        similarItems = []string{}
    }
    
    // 5. 更新物品记录
    item.SemanticIDs = semanticIDs
    item.Embedding = embedding
    item.ColdStartInfo = &ColdStartInfo{
        InitialEmbedding: embedding,
        SimilarItems:     similarItems,
        Understanding:    understanding,
        ProcessedAt:      time.Now(),
    }
    
    if err := p.itemRepo.Update(ctx, item); err != nil {
        return nil, fmt.Errorf("failed to update item: %w", err)
    }
    
    // 6. 写入向量数据库
    if err := p.vectorStore.Upsert(ctx, item.ItemID, embedding); err != nil {
        return nil, fmt.Errorf("failed to upsert vector: %w", err)
    }
    
    return &ProcessResult{
        ItemID:      item.ItemID,
        SemanticIDs: semanticIDs,
        Embedding:   embedding,
        SimilarItems: similarItems,
    }, nil
}

// understandItem LLM 语义理解
func (p *ItemProcessor) understandItem(ctx context.Context, item *Item) (*Understanding, error) {
    prompt := fmt.Sprintf(`
请分析以下物品信息，并提取结构化的语义特征：

物品标题: %s
物品描述: %s
类目路径: %s

请以 JSON 格式输出以下信息：
{
    "primary_category": "一级类目",
    "secondary_category": "二级类目",
    "attributes": {
        "品牌": "...",
        "价格区间": "低/中/高/奢侈",
        "风格": ["..."],
        "关键特征": ["..."]
    },
    "semantic_tags": ["语义标签1", "语义标签2"]
}

只输出 JSON，不要其他内容。
`, item.Title, truncate(item.Description, 500), item.CategoryPath)
    
    response, err := p.llmClient.Complete(ctx, prompt)
    if err != nil {
        return nil, err
    }
    
    var understanding Understanding
    if err := json.Unmarshal([]byte(response), &understanding); err != nil {
        return nil, fmt.Errorf("failed to parse LLM response: %w", err)
    }
    
    return &understanding, nil
}

// ruleBasedUnderstanding 规则降级
func (p *ItemProcessor) ruleBasedUnderstanding(item *Item) *Understanding {
    categories := strings.Split(item.CategoryPath, "/")
    
    understanding := &Understanding{
        PrimaryCategory: categories[0],
    }
    
    if len(categories) > 1 {
        understanding.SecondaryCategory = categories[1]
    }
    
    // 从标题提取关键词作为标签
    understanding.SemanticTags = extractKeywords(item.Title, 5)
    
    return understanding
}
```

---

## 3. 开发规范

### 3.1 分支管理

#### 3.1.1 分支策略 (Git Flow)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Git 分支策略                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  main ────────●────────●────────●────────●──────────────────────────────   │
│               ↑        ↑        ↑        ↑                                  │
│               │        │        │        │                                  │
│  release ─────┼────────┼────────┼────────┼──────●───●───●────────────────   │
│               │        │        │        │      ↑                           │
│               │        │        │        │      │                           │
│  develop ─────●────●───●────●───●────●───●──────●───────────────────────   │
│               ↑    │        │        │                                      │
│               │    │        │        │                                      │
│  feature/* ───┴────●        ●────────●                                      │
│                                                                             │
│  hotfix/* ──────────────────────────────────────────────────●───●          │
│                                                              ↓   ↓          │
│                                                           main release      │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3.1.2 分支命名规范

| 分支类型 | 命名格式 | 示例 |
|---------|---------|------|
| 主分支 | `main` | `main` |
| 开发分支 | `develop` | `develop` |
| 功能分支 | `feature/{ticket-id}-{brief-desc}` | `feature/REC-123-add-diversity` |
| 发布分支 | `release/v{major}.{minor}.{patch}` | `release/v1.2.0` |
| 热修复分支 | `hotfix/{ticket-id}-{brief-desc}` | `hotfix/REC-456-fix-timeout` |

### 3.2 代码审查

#### 3.2.1 审查清单

```markdown
## 代码审查清单

### 功能正确性
- [ ] 代码实现符合需求描述
- [ ] 边界条件处理正确
- [ ] 错误处理完整

### 代码质量
- [ ] 代码风格符合规范
- [ ] 变量/函数命名清晰
- [ ] 没有重复代码
- [ ] 复杂度可接受

### 性能
- [ ] 没有明显的性能问题
- [ ] 数据库查询已优化
- [ ] 缓存使用合理

### 安全
- [ ] 没有敏感信息硬编码
- [ ] 输入验证完整
- [ ] 没有 SQL 注入风险

### 可维护性
- [ ] 有必要的注释
- [ ] 日志记录充分
- [ ] 配置可外部化

### 测试
- [ ] 单元测试覆盖
- [ ] 测试用例有意义
- [ ] 测试通过
```

#### 3.2.2 Merge Request 模板

```markdown
## 变更描述

<!-- 简要描述本次变更的内容 -->

## 关联 Issue

<!-- 关联的 Issue 编号，如 #123 -->

## 变更类型

- [ ] 新功能 (feature)
- [ ] Bug 修复 (bugfix)
- [ ] 重构 (refactor)
- [ ] 文档 (docs)
- [ ] 测试 (test)
- [ ] 其他

## 测试说明

<!-- 描述如何测试本次变更 -->

## 检查清单

- [ ] 代码已自测
- [ ] 单元测试已更新
- [ ] 文档已更新
- [ ] 无破坏性变更

## 截图 (如有)

<!-- 附上相关截图 -->
```

### 3.3 单元测试规范

#### 3.3.1 测试覆盖率要求

| 模块 | 最低覆盖率 | 目标覆盖率 |
|------|-----------|-----------|
| 核心业务逻辑 | 80% | 90% |
| 工具类 | 70% | 85% |
| API Handler | 60% | 80% |
| 总体 | 75% | 85% |

#### 3.3.2 测试代码示例

```go
// internal/service/recommend/generate_test.go
package recommend

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// MockInferenceClient 推理客户端 Mock
type MockInferenceClient struct {
    mock.Mock
}

func (m *MockInferenceClient) Infer(ctx context.Context, req *InferenceRequest) (*InferenceResponse, error) {
    args := m.Called(ctx, req)
    return args.Get(0).(*InferenceResponse), args.Error(1)
}

func TestRecommendService_GenerateRecommendations(t *testing.T) {
    tests := []struct {
        name           string
        request        *GenerateRequest
        mockSetup      func(*MockInferenceClient)
        expectedCount  int
        expectedError  bool
    }{
        {
            name: "正常推荐",
            request: &GenerateRequest{
                UserID:  "user-123",
                SceneID: "home_feed",
                Count:   10,
            },
            mockSetup: func(m *MockInferenceClient) {
                m.On("Infer", mock.Anything, mock.Anything).Return(&InferenceResponse{
                    Items: generateMockItems(10),
                }, nil)
            },
            expectedCount: 10,
            expectedError: false,
        },
        {
            name: "空用户ID",
            request: &GenerateRequest{
                UserID:  "",
                SceneID: "home_feed",
                Count:   10,
            },
            mockSetup:     func(m *MockInferenceClient) {},
            expectedCount: 0,
            expectedError: true,
        },
        {
            name: "推理服务超时降级",
            request: &GenerateRequest{
                UserID:  "user-123",
                SceneID: "home_feed",
                Count:   10,
            },
            mockSetup: func(m *MockInferenceClient) {
                m.On("Infer", mock.Anything, mock.Anything).Return(
                    (*InferenceResponse)(nil), context.DeadlineExceeded,
                )
            },
            expectedCount: 10,  // 降级返回热门物品
            expectedError: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup
            mockClient := new(MockInferenceClient)
            tt.mockSetup(mockClient)
            
            service := NewRecommendService(
                WithInferenceClient(mockClient),
                WithConfig(&Config{EnableFallback: true}),
            )
            
            // Execute
            resp, err := service.GenerateRecommendations(context.Background(), tt.request)
            
            // Assert
            if tt.expectedError {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, resp)
                assert.Len(t, resp.Items, tt.expectedCount)
            }
            
            mockClient.AssertExpectations(t)
        })
    }
}

func TestEnhanceDiversity(t *testing.T) {
    service := &RecommendService{
        config: &Config{
            MaxCategoryItems: 2,
            MaxBrandItems:    1,
        },
    }
    
    items := []*RecommendItem{
        {ItemID: "1", Category: "electronics", Brand: "Apple", Score: 0.9},
        {ItemID: "2", Category: "electronics", Brand: "Apple", Score: 0.85},
        {ItemID: "3", Category: "electronics", Brand: "Samsung", Score: 0.8},
        {ItemID: "4", Category: "fashion", Brand: "Nike", Score: 0.75},
        {ItemID: "5", Category: "electronics", Brand: "Sony", Score: 0.7},
    }
    
    result := service.enhanceDiversity(items, 4)
    
    assert.Len(t, result, 4)
    
    // 验证类目多样性
    categoryCount := make(map[string]int)
    for _, item := range result {
        categoryCount[item.Category]++
    }
    assert.LessOrEqual(t, categoryCount["electronics"], 2)
    
    // 验证品牌多样性
    brandCount := make(map[string]int)
    for _, item := range result {
        brandCount[item.Brand]++
    }
    assert.LessOrEqual(t, brandCount["Apple"], 1)
}

func generateMockItems(count int) []*RecommendItem {
    items := make([]*RecommendItem, count)
    for i := 0; i < count; i++ {
        items[i] = &RecommendItem{
            ItemID:   fmt.Sprintf("item-%d", i),
            Score:    1.0 - float32(i)*0.1,
            Category: "electronics",
        }
    }
    return items
}
```

---

## 4. 测试方案

### 4.1 测试分层

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         测试金字塔                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                          ┌─────────────┐                                    │
│                          │   E2E 测试   │  5%                               │
│                          │  (端到端)    │                                   │
│                          └──────┬──────┘                                    │
│                                 │                                           │
│                    ┌────────────┴────────────┐                              │
│                    │       集成测试          │  15%                          │
│                    │   (API/服务间调用)      │                              │
│                    └────────────┬────────────┘                              │
│                                 │                                           │
│          ┌──────────────────────┴──────────────────────┐                    │
│          │                单元测试                      │  80%               │
│          │          (函数/方法级别)                     │                    │
│          └─────────────────────────────────────────────┘                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 集成测试

```go
// tests/integration/recommend_test.go
package integration

import (
    "context"
    "net/http"
    "testing"
    "time"
    
    "github.com/stretchr/testify/suite"
)

type RecommendIntegrationSuite struct {
    suite.Suite
    client *http.Client
    baseURL string
}

func (s *RecommendIntegrationSuite) SetupSuite() {
    s.client = &http.Client{Timeout: 10 * time.Second}
    s.baseURL = getTestServerURL()
}

func (s *RecommendIntegrationSuite) TestGenerateRecommendations() {
    // 准备测试数据
    userID := createTestUser(s.T())
    defer cleanupTestUser(userID)
    
    // 发送请求
    req := &GenerateRequest{
        UserID:  userID,
        SceneID: "home_feed",
        Count:   20,
    }
    
    resp, err := s.postJSON("/v1/recommend/generate", req)
    s.NoError(err)
    s.Equal(http.StatusOK, resp.StatusCode)
    
    // 验证响应
    var result GenerateResponse
    s.NoError(json.NewDecoder(resp.Body).Decode(&result))
    
    s.Equal(0, result.Code)
    s.NotEmpty(result.Data.RequestID)
    s.Len(result.Data.Items, 20)
    
    // 验证每个推荐项
    for _, item := range result.Data.Items {
        s.NotEmpty(item.ItemID)
        s.NotEmpty(item.Title)
        s.Greater(item.Score, float32(0))
    }
}

func (s *RecommendIntegrationSuite) TestRecommendFeedback() {
    // 先获取推荐
    userID := createTestUser(s.T())
    defer cleanupTestUser(userID)
    
    recResp := s.getRecommendations(userID, 10)
    
    // 发送反馈
    feedbackReq := &FeedbackRequest{
        RequestID:    recResp.RequestID,
        UserID:       userID,
        ItemID:       recResp.Items[0].ItemID,
        FeedbackType: "click",
    }
    
    resp, err := s.postJSON("/v1/recommend/feedback", feedbackReq)
    s.NoError(err)
    s.Equal(http.StatusOK, resp.StatusCode)
}

func TestRecommendIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }
    suite.Run(t, new(RecommendIntegrationSuite))
}
```

### 4.3 性能测试

#### 4.3.1 性能测试场景

| 场景 | 并发数 | 持续时间 | 目标 |
|------|-------|---------|------|
| 基准测试 | 100 | 5min | 建立性能基线 |
| 压力测试 | 1000 | 30min | 验证正常负载 |
| 峰值测试 | 5000 | 10min | 验证峰值处理 |
| 持久测试 | 500 | 24h | 验证稳定性 |

#### 4.3.2 性能测试脚本 (k6)

```javascript
// tests/performance/recommend.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// 自定义指标
const errorRate = new Rate('errors');
const recommendLatency = new Trend('recommend_latency');

export const options = {
    stages: [
        { duration: '1m', target: 100 },   // 预热
        { duration: '5m', target: 500 },   // 正常负载
        { duration: '2m', target: 1000 },  // 压力测试
        { duration: '1m', target: 0 },     // 冷却
    ],
    thresholds: {
        http_req_duration: ['p(95)<100', 'p(99)<200'],  // 延迟阈值
        errors: ['rate<0.01'],                           // 错误率 < 1%
    },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';
const TOKEN = __ENV.API_TOKEN;

export default function () {
    // 模拟用户 ID
    const userId = `user-${Math.floor(Math.random() * 1000000)}`;
    
    // 推荐请求
    const payload = JSON.stringify({
        user_id: userId,
        scene_id: 'home_feed',
        count: 20,
    });
    
    const params = {
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${TOKEN}`,
        },
    };
    
    const startTime = Date.now();
    const res = http.post(`${BASE_URL}/v1/recommend/generate`, payload, params);
    const latency = Date.now() - startTime;
    
    // 记录指标
    recommendLatency.add(latency);
    
    // 检查响应
    const success = check(res, {
        'status is 200': (r) => r.status === 200,
        'response has items': (r) => {
            const body = JSON.parse(r.body);
            return body.data && body.data.items && body.data.items.length > 0;
        },
        'latency < 100ms': () => latency < 100,
    });
    
    errorRate.add(!success);
    
    sleep(0.5);  // 模拟用户思考时间
}
```

### 4.4 验收标准

| 指标 | 验收标准 | 测试方法 |
|------|---------|---------|
| API 响应时间 | P50 < 50ms, P99 < 200ms | 性能测试 |
| 错误率 | < 0.1% | 压力测试 |
| 吞吐量 | > 10000 QPS (单节点) | 基准测试 |
| 可用性 | > 99.9% | 持久测试 |
| 推荐多样性 | 类目数 >= 3 | 功能测试 |
| 冷启动延迟 | < 5s | 功能测试 |

---

## 5. 部署方案

### 5.1 CI/CD 流程

```yaml
# .gitlab-ci.yml
stages:
  - lint
  - test
  - build
  - deploy-staging
  - deploy-prod

variables:
  DOCKER_REGISTRY: registry.example.com
  IMAGE_NAME: recommend-service

# 代码检查
lint:
  stage: lint
  image: golangci/golangci-lint:latest
  script:
    - golangci-lint run ./...
  only:
    - merge_requests
    - develop
    - main

# 单元测试
test:
  stage: test
  image: golang:1.22
  services:
    - redis:7
    - postgres:16
  variables:
    REDIS_HOST: redis
    POSTGRES_HOST: postgres
    POSTGRES_DB: test_db
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
  script:
    - go test -v -cover -coverprofile=coverage.out ./...
    - go tool cover -func=coverage.out | grep total | awk '{print $3}'
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  only:
    - merge_requests
    - develop
    - main

# 构建镜像
build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  script:
    - docker build -t $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA .
    - docker tag $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_REGISTRY/$IMAGE_NAME:latest
    - docker push $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA
    - docker push $DOCKER_REGISTRY/$IMAGE_NAME:latest
  only:
    - develop
    - main

# 部署到 Staging
deploy-staging:
  stage: deploy-staging
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context staging
    - kubectl set image deployment/recommend-service recommend-service=$DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA -n recommend
    - kubectl rollout status deployment/recommend-service -n recommend --timeout=300s
  environment:
    name: staging
    url: https://staging-api.example.com
  only:
    - develop

# 部署到生产 (手动触发)
deploy-prod:
  stage: deploy-prod
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context production
    - kubectl set image deployment/recommend-service recommend-service=$DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHA -n recommend
    - kubectl rollout status deployment/recommend-service -n recommend --timeout=600s
  environment:
    name: production
    url: https://api.example.com
  when: manual
  only:
    - main
```

### 5.2 Dockerfile

```dockerfile
# Dockerfile
# 多阶段构建

# 阶段 1: 构建
FROM golang:1.22-alpine AS builder

WORKDIR /app

# 安装依赖
RUN apk add --no-cache git ca-certificates

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s -X main.Version=${VERSION}" \
    -o /app/recommend-service \
    ./cmd/recommend-service

# 阶段 2: 运行
FROM alpine:3.19

WORKDIR /app

# 安装运行时依赖
RUN apk add --no-cache ca-certificates tzdata

# 设置时区
ENV TZ=Asia/Shanghai

# 复制二进制文件
COPY --from=builder /app/recommend-service /app/
COPY --from=builder /app/configs /app/configs

# 创建非 root 用户
RUN adduser -D -u 1000 appuser
USER appuser

# 暴露端口
EXPOSE 8080 9090 9091

# 健康检查
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health/live || exit 1

# 启动命令
ENTRYPOINT ["/app/recommend-service"]
CMD ["--config", "/app/configs/config.yaml"]
```

### 5.3 环境配置

| 环境 | 配置特点 | 副本数 | 资源配置 |
|------|---------|--------|---------|
| dev | 单实例，本地数据库 | 1 | 0.5C/512M |
| staging | 多实例，共享数据库 | 3 | 1C/1G |
| prod | 高可用，独立数据库 | 10+ | 2C/2G |

---

## 6. 运维方案

### 6.1 监控指标

#### 6.1.1 业务指标

```yaml
# prometheus/rules/recommend.yml
groups:
  - name: recommend_business
    rules:
      # QPS
      - record: recommend:qps:rate5m
        expr: sum(rate(recommend_requests_total[5m]))
      
      # 延迟分位数
      - record: recommend:latency:p50
        expr: histogram_quantile(0.50, sum(rate(recommend_request_duration_seconds_bucket[5m])) by (le))
      
      - record: recommend:latency:p99
        expr: histogram_quantile(0.99, sum(rate(recommend_request_duration_seconds_bucket[5m])) by (le))
      
      # 错误率
      - record: recommend:error_rate:rate5m
        expr: sum(rate(recommend_errors_total[5m])) / sum(rate(recommend_requests_total[5m]))
      
      # 降级率
      - record: recommend:fallback_rate:rate5m
        expr: sum(rate(recommend_fallback_total[5m])) / sum(rate(recommend_requests_total[5m]))
      
      # 推理成功率
      - record: inference:success_rate:rate5m
        expr: 1 - (sum(rate(inference_errors_total[5m])) / sum(rate(inference_requests_total[5m])))
```

#### 6.1.2 告警规则

```yaml
# prometheus/alerts/recommend.yml
groups:
  - name: recommend_alerts
    rules:
      # 高延迟告警
      - alert: RecommendHighLatency
        expr: recommend:latency:p99 > 0.2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "推荐服务 P99 延迟过高"
          description: "P99 延迟 {{ $value | humanizeDuration }} 超过 200ms"
      
      # 高错误率告警
      - alert: RecommendHighErrorRate
        expr: recommend:error_rate:rate5m > 0.01
        for: 3m
        labels:
          severity: critical
        annotations:
          summary: "推荐服务错误率过高"
          description: "错误率 {{ $value | humanizePercentage }} 超过 1%"
      
      # 推理服务异常
      - alert: InferenceServiceDown
        expr: inference:success_rate:rate5m < 0.95
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "推理服务成功率下降"
          description: "推理成功率 {{ $value | humanizePercentage }} 低于 95%"
      
      # 高降级率告警
      - alert: HighFallbackRate
        expr: recommend:fallback_rate:rate5m > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "推荐降级率过高"
          description: "降级率 {{ $value | humanizePercentage }} 超过 10%"
```

### 6.2 日志规范

#### 6.2.1 日志格式

```json
{
  "timestamp": "2026-01-04T10:30:00.123Z",
  "level": "INFO",
  "service": "recommend-service",
  "trace_id": "abc123",
  "span_id": "def456",
  "user_id": "U123456",
  "request_id": "req-001",
  "message": "推荐生成完成",
  "latency_ms": 23,
  "item_count": 20,
  "is_fallback": false
}
```

#### 6.2.2 日志级别使用

| 级别 | 使用场景 |
|------|---------|
| ERROR | 需要立即关注的错误，如服务不可用 |
| WARN | 可能的问题，如降级、重试 |
| INFO | 重要业务事件，如请求处理完成 |
| DEBUG | 调试信息，生产环境默认关闭 |

### 6.3 应急预案

#### 6.3.1 常见故障处理

| 故障类型 | 影响 | 处理步骤 |
|---------|------|---------|
| 推理服务超时 | 推荐延迟上升 | 1. 自动降级到热门推荐 2. 检查 GPU 状态 3. 重启推理服务 |
| 特征服务异常 | 推荐质量下降 | 1. 使用缓存特征 2. 检查 Redis 状态 3. 切换备用节点 |
| 数据库连接池耗尽 | 服务不可用 | 1. 扩容连接池 2. 检查慢查询 3. 重启服务 |
| 缓存穿透 | 数据库压力大 | 1. 启用空值缓存 2. 布隆过滤器 3. 限流 |

#### 6.3.2 回滚流程

```bash
#!/bin/bash
# scripts/rollback.sh

set -e

NAMESPACE="recommend"
DEPLOYMENT="recommend-service"
REVISION="${1:-1}"  # 默认回滚到上一版本

echo "=== 开始回滚 ==="
echo "Namespace: $NAMESPACE"
echo "Deployment: $DEPLOYMENT"
echo "Target Revision: $REVISION"

# 查看历史版本
echo "=== 版本历史 ==="
kubectl rollout history deployment/$DEPLOYMENT -n $NAMESPACE

# 确认回滚
read -p "确认回滚到版本 $REVISION? (y/n) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "取消回滚"
    exit 1
fi

# 执行回滚
echo "=== 执行回滚 ==="
kubectl rollout undo deployment/$DEPLOYMENT -n $NAMESPACE --to-revision=$REVISION

# 等待完成
echo "=== 等待回滚完成 ==="
kubectl rollout status deployment/$DEPLOYMENT -n $NAMESPACE --timeout=300s

# 验证
echo "=== 验证状态 ==="
kubectl get pods -n $NAMESPACE -l app=$DEPLOYMENT

echo "=== 回滚完成 ==="
```

---

## 7. 上线方案

### 7.1 灰度发布策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         灰度发布流程                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  阶段 1: 内部测试 (0.1%)                                                     │
│  ├─ 时长: 1-2 小时                                                          │
│  ├─ 对象: 内部员工                                                          │
│  └─ 验证: 功能正确性、无明显错误                                              │
│                    │                                                        │
│                    ▼                                                        │
│  阶段 2: 小流量 (5%)                                                         │
│  ├─ 时长: 4-8 小时                                                          │
│  ├─ 对象: 随机用户                                                          │
│  └─ 验证: 性能指标、业务指标                                                  │
│                    │                                                        │
│                    ▼                                                        │
│  阶段 3: 中流量 (20%)                                                        │
│  ├─ 时长: 24 小时                                                           │
│  ├─ 对象: 随机用户                                                          │
│  └─ 验证: 稳定性、资源消耗                                                    │
│                    │                                                        │
│                    ▼                                                        │
│  阶段 4: 大流量 (50%)                                                        │
│  ├─ 时长: 24-48 小时                                                        │
│  ├─ 对象: 随机用户                                                          │
│  └─ 验证: 全面业务指标                                                       │
│                    │                                                        │
│                    ▼                                                        │
│  阶段 5: 全量 (100%)                                                         │
│  ├─ 老版本保留 1 周                                                          │
│  └─ 持续监控                                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 Istio 灰度配置

```yaml
# deployments/istio/canary.yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: recommend-service
  namespace: recommend
spec:
  hosts:
    - recommend-service
  http:
    # 灰度流量
    - match:
        - headers:
            x-canary:
              exact: "true"
      route:
        - destination:
            host: recommend-service
            subset: canary
    # 正常流量分配
    - route:
        - destination:
            host: recommend-service
            subset: stable
          weight: 95
        - destination:
            host: recommend-service
            subset: canary
          weight: 5
---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: recommend-service
  namespace: recommend
spec:
  host: recommend-service
  subsets:
    - name: stable
      labels:
        version: stable
    - name: canary
      labels:
        version: canary
```

### 7.3 上线检查清单

```markdown
## 上线前检查

### 代码准备
- [ ] 代码已合并到 main 分支
- [ ] 所有测试通过
- [ ] 代码审查已完成
- [ ] 变更日志已更新

### 配置检查
- [ ] 生产配置已准备
- [ ] 敏感信息已加密
- [ ] 功能开关已设置

### 数据库
- [ ] 数据库迁移脚本已准备
- [ ] 迁移脚本已在 staging 验证
- [ ] 回滚脚本已准备

### 依赖服务
- [ ] 依赖服务版本兼容
- [ ] 依赖服务健康

### 监控告警
- [ ] 监控仪表盘已更新
- [ ] 告警规则已配置
- [ ] 值班人员已通知

### 应急准备
- [ ] 回滚方案已确认
- [ ] 应急联系人已确认
- [ ] 故障处理预案已就绪

---

## 上线后验证

### 即时验证 (5分钟内)
- [ ] 服务启动正常
- [ ] 健康检查通过
- [ ] 日志无错误

### 短期验证 (30分钟内)
- [ ] 请求正常处理
- [ ] 延迟在预期范围
- [ ] 错误率正常

### 中期验证 (2小时内)
- [ ] 业务指标正常
- [ ] 资源消耗正常
- [ ] 无异常告警

### 长期验证 (24小时)
- [ ] 系统稳定运行
- [ ] 无性能衰减
- [ ] 用户反馈正常
```

### 7.4 回滚条件

| 指标 | 回滚阈值 | 观察时长 |
|------|---------|---------|
| 错误率 | > 1% | 5 分钟 |
| P99 延迟 | > 500ms | 10 分钟 |
| 服务可用性 | < 99% | 5 分钟 |
| 降级率 | > 20% | 15 分钟 |
| CPU 使用率 | > 90% | 10 分钟 |

### 7.5 上线时间窗口

| 时间窗口 | 适用场景 | 说明 |
|---------|---------|------|
| 工作日 10:00-12:00 | 常规发布 | 流量较低，便于观察 |
| 工作日 14:00-17:00 | 常规发布 | 团队在岗，响应快 |
| 周末/节假日 | 禁止 | 除非紧急修复 |
| 大促前 3 天 | 禁止 | 代码冻结期 |

---

## 附录

### A. 常用命令

```bash
# 查看服务状态
kubectl get pods -n recommend -l app=recommend-service

# 查看日志
kubectl logs -f deployment/recommend-service -n recommend

# 进入容器
kubectl exec -it deployment/recommend-service -n recommend -- /bin/sh

# 端口转发 (本地调试)
kubectl port-forward svc/recommend-service 8080:80 -n recommend

# 查看资源使用
kubectl top pods -n recommend

# 扩缩容
kubectl scale deployment/recommend-service --replicas=20 -n recommend

# 查看发布历史
kubectl rollout history deployment/recommend-service -n recommend

# 回滚
kubectl rollout undo deployment/recommend-service -n recommend
```

### B. 监控仪表盘

| 仪表盘 | 用途 | URL |
|--------|------|-----|
| 服务概览 | 核心指标汇总 | `/d/recommend-overview` |
| 推理性能 | 模型推理监控 | `/d/inference-performance` |
| 业务效果 | CTR/CVR 等 | `/d/business-metrics` |
| 资源监控 | CPU/内存/网络 | `/d/resource-usage` |
| 依赖服务 | Redis/PG/Kafka | `/d/dependencies` |

### C. 联系人

| 角色 | 职责 | 联系方式 |
|------|------|---------|
| 技术负责人 | 技术决策 | tech-lead@example.com |
| 运维负责人 | 线上问题 | ops@example.com |
| 值班工程师 | 7x24 响应 | oncall@example.com |
| 告警群 | 告警通知 | 企微群: 推荐系统告警 |

---

> **文档版本历史**
> - v1.0 (2026-01-04): 初始版本，完整功能实现与生命周期指导

