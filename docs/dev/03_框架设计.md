# 框架设计文档

> 版本: v1.0  
> 更新日期: 2026-01-04  
> 对应架构文档: 《生成式推荐系统架构设计》第二章、第七章

---

## 目录

1. [概述](#1-概述)
2. [后端架构设计](#2-后端架构设计)
3. [前端架构设计](#3-前端架构设计)
4. [数据库架构设计](#4-数据库架构设计)
5. [服务通信设计](#5-服务通信设计)
6. [部署架构设计](#6-部署架构设计)

---

## 1. 概述

### 1.1 文档目的

本文档详细描述生成式推荐系统的框架设计方案，包括后端服务架构、前端组件设计、数据库设计和部署架构。

### 1.2 架构设计原则

| 原则 | 说明 |
|------|------|
| **微服务架构** | 按业务域拆分服务，独立部署、独立扩展 |
| **分层解耦** | 表现层、业务层、数据层清晰分离 |
| **高可用** | 无单点故障，支持优雅降级 |
| **可观测** | 全链路追踪、统一监控告警 |
| **渐进迁移** | 支持新老系统并行运行 |

---

## 2. 后端架构设计

### 2.1 服务架构总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         后端微服务架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        API Gateway (Kong)                            │   │
│  │  认证 | 限流 | 路由 | 熔断 | 日志                                      │   │
│  └───────────────────────────────┬─────────────────────────────────────┘   │
│                                  │                                          │
│  ┌───────────────────────────────┴─────────────────────────────────────┐   │
│  │                      服务网格 (Istio)                                 │   │
│  └───────────────────────────────┬─────────────────────────────────────┘   │
│                                  │                                          │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐        │
│  │ 用户服务  │ │ 物品服务  │ │ 推荐服务  │ │ 特征服务  │ │ 冷启动服务 │        │
│  │ user-svc │ │ item-svc │ │ rec-svc  │ │ feat-svc │ │ cold-svc │        │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘        │
│       │            │            │            │            │              │
│  ┌────┴────────────┴────────────┴────────────┴────────────┴──────────┐   │
│  │                      数据访问层 (Repository)                        │   │
│  └───────────────────────────────┬───────────────────────────────────┘   │
│                                  │                                          │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐        │
│  │PostgreSQL│ │  Milvus  │ │  Redis   │ │ClickHouse│ │  Kafka   │        │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心服务设计

#### 2.2.1 推荐服务 (recommend-service)

**职责**: 核心推荐逻辑，调用模型生成推荐结果

```go
// internal/service/recommend/service.go
package recommend

import (
    "context"
    "time"
    
    pb "recommend-system/api/recommend/v1"
    "recommend-system/internal/model"
    "recommend-system/internal/inference"
    "recommend-system/internal/cache"
)

// RecommendService 推荐服务
type RecommendService struct {
    pb.UnimplementedRecommendServiceServer
    
    inferenceClient inference.Client      // 模型推理客户端
    featureService  *FeatureService       // 特征服务
    cache           cache.Cache           // 缓存
    itemRepo        repository.ItemRepo   // 物品仓储
    config          *Config
}

// Config 服务配置
type Config struct {
    DefaultCount      int           `yaml:"default_count"`
    MaxCount          int           `yaml:"max_count"`
    CacheTTL          time.Duration `yaml:"cache_ttl"`
    InferenceTimeout  time.Duration `yaml:"inference_timeout"`
    EnableFallback    bool          `yaml:"enable_fallback"`
}

// Generate 生成推荐
func (s *RecommendService) Generate(ctx context.Context, req *pb.GenerateRequest) (*pb.GenerateResponse, error) {
    // 1. 参数校验
    if err := s.validateRequest(req); err != nil {
        return nil, err
    }
    
    // 2. 尝试从缓存获取
    cacheKey := s.buildCacheKey(req)
    if cached, ok := s.cache.Get(ctx, cacheKey); ok {
        return cached.(*pb.GenerateResponse), nil
    }
    
    // 3. 获取用户特征
    userFeatures, err := s.featureService.GetUserFeatures(ctx, req.UserId)
    if err != nil {
        // 降级：使用默认特征
        userFeatures = s.getDefaultFeatures()
    }
    
    // 4. 调用模型推理
    inferenceReq := &inference.Request{
        UserID:       req.UserId,
        Features:     userFeatures,
        Count:        int(req.Count),
        Context:      req.ContextFeatures,
    }
    
    ctx, cancel := context.WithTimeout(ctx, s.config.InferenceTimeout)
    defer cancel()
    
    inferenceResp, err := s.inferenceClient.Infer(ctx, inferenceReq)
    if err != nil {
        if s.config.EnableFallback {
            return s.fallbackRecommend(ctx, req)
        }
        return nil, err
    }
    
    // 5. 补充物品信息
    items, err := s.enrichItems(ctx, inferenceResp.ItemIDs)
    if err != nil {
        return nil, err
    }
    
    // 6. 构建响应
    response := &pb.GenerateResponse{
        RequestId: generateRequestID(),
        Items:     items,
        Metadata: &pb.ResponseMetadata{
            AlgorithmVersion: inferenceResp.ModelVersion,
            LatencyMs:        int32(time.Since(start).Milliseconds()),
        },
    }
    
    // 7. 写入缓存
    s.cache.Set(ctx, cacheKey, response, s.config.CacheTTL)
    
    return response, nil
}

// fallbackRecommend 降级推荐
func (s *RecommendService) fallbackRecommend(ctx context.Context, req *pb.GenerateRequest) (*pb.GenerateResponse, error) {
    // 降级策略：返回热门物品
    hotItems, err := s.cache.GetHotItems(ctx, int(req.Count))
    if err != nil {
        return nil, err
    }
    
    return &pb.GenerateResponse{
        RequestId: generateRequestID(),
        Items:     hotItems,
        Metadata: &pb.ResponseMetadata{
            IsFallback: true,
        },
    }, nil
}
```

#### 2.2.2 用户服务 (user-service)

**职责**: 用户信息管理、用户画像

```go
// internal/service/user/service.go
package user

import (
    "context"
    
    pb "recommend-system/api/user/v1"
    "recommend-system/internal/repository"
)

// UserService 用户服务
type UserService struct {
    pb.UnimplementedUserServiceServer
    
    userRepo    repository.UserRepo
    eventRepo   repository.EventRepo
    profileRepo repository.ProfileRepo
    cache       cache.Cache
}

// GetUser 获取用户信息
func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    // 1. 尝试缓存
    cacheKey := fmt.Sprintf("user:%s", req.UserId)
    if cached, ok := s.cache.Get(ctx, cacheKey); ok {
        return cached.(*pb.User), nil
    }
    
    // 2. 查询数据库
    user, err := s.userRepo.GetByID(ctx, req.UserId)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    s.cache.Set(ctx, cacheKey, user, 10*time.Minute)
    
    return user, nil
}

// GetUserProfile 获取用户画像
func (s *UserService) GetUserProfile(ctx context.Context, req *pb.GetUserProfileRequest) (*pb.UserProfile, error) {
    // 获取基础画像
    profile, err := s.profileRepo.GetByUserID(ctx, req.UserId)
    if err != nil {
        return nil, err
    }
    
    // 补充实时特征
    recentEvents, err := s.eventRepo.GetRecentEvents(ctx, req.UserId, 100)
    if err == nil {
        profile.RecentBehaviors = s.summarizeEvents(recentEvents)
    }
    
    return profile, nil
}

// RecordEvent 记录用户行为
func (s *UserService) RecordEvent(ctx context.Context, req *pb.RecordEventRequest) (*pb.RecordEventResponse, error) {
    event := &model.UserEvent{
        UserID:    req.UserId,
        EventType: req.EventType,
        ItemID:    req.ItemId,
        Timestamp: time.Now(),
        Context:   req.Context,
    }
    
    // 1. 写入数据库
    if err := s.eventRepo.Create(ctx, event); err != nil {
        return nil, err
    }
    
    // 2. 发送到 Kafka（异步处理）
    s.publishEvent(event)
    
    // 3. 更新实时缓存
    s.updateUserCache(ctx, req.UserId, event)
    
    return &pb.RecordEventResponse{Success: true}, nil
}
```

#### 2.2.3 物品服务 (item-service)

**职责**: 物品信息管理、语义 ID 管理

```go
// internal/service/item/service.go
package item

import (
    "context"
    
    pb "recommend-system/api/item/v1"
    "recommend-system/internal/repository"
)

// ItemService 物品服务
type ItemService struct {
    pb.UnimplementedItemServiceServer
    
    itemRepo     repository.ItemRepo
    semanticRepo repository.SemanticIDRepo
    vectorRepo   repository.VectorRepo
    cache        cache.Cache
    encoder      *SemanticEncoder
}

// GetItem 获取物品信息
func (s *ItemService) GetItem(ctx context.Context, req *pb.GetItemRequest) (*pb.Item, error) {
    cacheKey := fmt.Sprintf("item:%s", req.ItemId)
    
    if cached, ok := s.cache.Get(ctx, cacheKey); ok {
        return cached.(*pb.Item), nil
    }
    
    item, err := s.itemRepo.GetByID(ctx, req.ItemId)
    if err != nil {
        return nil, err
    }
    
    s.cache.Set(ctx, cacheKey, item, 30*time.Minute)
    return item, nil
}

// BatchGetItems 批量获取物品
func (s *ItemService) BatchGetItems(ctx context.Context, req *pb.BatchGetItemsRequest) (*pb.BatchGetItemsResponse, error) {
    items := make([]*pb.Item, 0, len(req.ItemIds))
    missingIDs := make([]string, 0)
    
    // 1. 先从缓存获取
    for _, id := range req.ItemIds {
        cacheKey := fmt.Sprintf("item:%s", id)
        if cached, ok := s.cache.Get(ctx, cacheKey); ok {
            items = append(items, cached.(*pb.Item))
        } else {
            missingIDs = append(missingIDs, id)
        }
    }
    
    // 2. 缓存未命中的从数据库获取
    if len(missingIDs) > 0 {
        dbItems, err := s.itemRepo.BatchGetByIDs(ctx, missingIDs)
        if err != nil {
            return nil, err
        }
        
        for _, item := range dbItems {
            items = append(items, item)
            // 写入缓存
            cacheKey := fmt.Sprintf("item:%s", item.ItemId)
            s.cache.Set(ctx, cacheKey, item, 30*time.Minute)
        }
    }
    
    return &pb.BatchGetItemsResponse{Items: items}, nil
}

// CreateItem 创建物品
func (s *ItemService) CreateItem(ctx context.Context, req *pb.CreateItemRequest) (*pb.Item, error) {
    // 1. 生成语义 ID
    semanticIDs, err := s.encoder.Encode(ctx, &EncoderInput{
        Title:       req.Title,
        Description: req.Description,
        Category:    req.CategoryPath,
    })
    if err != nil {
        return nil, err
    }
    
    // 2. 创建物品记录
    item := &model.Item{
        ItemID:       generateItemID(),
        Title:        req.Title,
        Description:  req.Description,
        CategoryPath: req.CategoryPath,
        SemanticIDs:  semanticIDs,
        Status:       model.ItemStatusActive,
        CreatedAt:    time.Now(),
    }
    
    if err := s.itemRepo.Create(ctx, item); err != nil {
        return nil, err
    }
    
    // 3. 写入向量数据库
    if err := s.vectorRepo.Upsert(ctx, item.ItemID, semanticIDs.Embedding); err != nil {
        // 记录错误但不阻断流程
        log.Warnf("failed to upsert vector: %v", err)
    }
    
    return item.ToProto(), nil
}
```

#### 2.2.4 特征服务 (feature-service)

**职责**: 特征获取、特征工程

```go
// internal/service/feature/service.go
package feature

import (
    "context"
    "sync"
    
    pb "recommend-system/api/feature/v1"
)

// FeatureService 特征服务
type FeatureService struct {
    pb.UnimplementedFeatureServiceServer
    
    userFeatureStore  FeatureStore
    itemFeatureStore  FeatureStore
    crossFeatureStore FeatureStore
    cache             cache.Cache
}

// GetUserFeatures 获取用户特征
func (s *FeatureService) GetUserFeatures(ctx context.Context, req *pb.GetUserFeaturesRequest) (*pb.UserFeatures, error) {
    var wg sync.WaitGroup
    var mu sync.Mutex
    
    features := &pb.UserFeatures{
        UserId: req.UserId,
    }
    
    // 并行获取多类特征
    wg.Add(3)
    
    // 1. 基础画像特征
    go func() {
        defer wg.Done()
        if profile, err := s.userFeatureStore.GetProfile(ctx, req.UserId); err == nil {
            mu.Lock()
            features.ProfileFeatures = profile
            mu.Unlock()
        }
    }()
    
    // 2. 行为特征
    go func() {
        defer wg.Done()
        if behavior, err := s.userFeatureStore.GetBehavior(ctx, req.UserId); err == nil {
            mu.Lock()
            features.BehaviorFeatures = behavior
            mu.Unlock()
        }
    }()
    
    // 3. 实时特征
    go func() {
        defer wg.Done()
        if realtime, err := s.userFeatureStore.GetRealtime(ctx, req.UserId); err == nil {
            mu.Lock()
            features.RealtimeFeatures = realtime
            mu.Unlock()
        }
    }()
    
    wg.Wait()
    
    return features, nil
}

// GetItemFeatures 获取物品特征
func (s *FeatureService) GetItemFeatures(ctx context.Context, req *pb.GetItemFeaturesRequest) (*pb.ItemFeatures, error) {
    // 批量获取物品特征
    features := make([]*pb.SingleItemFeature, 0, len(req.ItemIds))
    
    for _, itemID := range req.ItemIds {
        itemFeature, err := s.itemFeatureStore.Get(ctx, itemID)
        if err != nil {
            continue
        }
        features = append(features, itemFeature)
    }
    
    return &pb.ItemFeatures{Items: features}, nil
}
```

#### 2.2.5 冷启动服务 (cold-start-service)

**职责**: 新用户/新物品冷启动处理

```go
// internal/service/coldstart/service.go
package coldstart

import (
    "context"
    
    pb "recommend-system/api/coldstart/v1"
    "recommend-system/internal/llm"
)

// ColdStartService 冷启动服务
type ColdStartService struct {
    pb.UnimplementedColdStartServiceServer
    
    llmClient       llm.Client
    semanticEncoder *SemanticEncoder
    itemRepo        repository.ItemRepo
    cache           cache.Cache
}

// ProcessNewItem 处理新物品
func (s *ColdStartService) ProcessNewItem(ctx context.Context, req *pb.ProcessNewItemRequest) (*pb.ProcessNewItemResponse, error) {
    // 1. LLM 语义理解
    understanding, err := s.llmClient.UnderstandItem(ctx, &llm.ItemInput{
        Title:       req.Title,
        Description: req.Description,
        Category:    req.CategoryPath,
    })
    if err != nil {
        // 降级：使用规则生成
        understanding = s.fallbackUnderstanding(req)
    }
    
    // 2. 生成语义 ID
    semanticIDs, err := s.semanticEncoder.Encode(ctx, understanding)
    if err != nil {
        return nil, err
    }
    
    // 3. 生成初始嵌入
    embedding, err := s.generateInitialEmbedding(ctx, understanding, semanticIDs)
    if err != nil {
        return nil, err
    }
    
    // 4. 找相似物品（用于推荐桥接）
    similarItems, err := s.findSimilarItems(ctx, embedding, 10)
    if err != nil {
        similarItems = []string{}
    }
    
    return &pb.ProcessNewItemResponse{
        ItemId:           req.ItemId,
        SemanticIds:      semanticIDs,
        InitialEmbedding: embedding,
        SimilarItems:     similarItems,
        Understanding:    understanding.ToProto(),
    }, nil
}

// ProcessNewUser 处理新用户
func (s *ColdStartService) ProcessNewUser(ctx context.Context, req *pb.ProcessNewUserRequest) (*pb.ProcessNewUserResponse, error) {
    // 1. 基于注册信息生成初始画像
    profile := s.generateInitialProfile(req)
    
    // 2. 确定探索策略
    explorationRate := 0.5  // 新用户探索率较高
    if len(req.InitialPreferences) > 0 {
        explorationRate = 0.3
    }
    
    // 3. 生成初始推荐候选集
    candidates, err := s.generateInitialCandidates(ctx, profile)
    if err != nil {
        return nil, err
    }
    
    return &pb.ProcessNewUserResponse{
        UserId:          req.UserId,
        InitialProfile:  profile,
        ExplorationRate: explorationRate,
        InitialCandidates: candidates,
    }, nil
}
```

### 2.3 项目目录结构

```
recommend-system/
├── api/                          # API 定义 (Protobuf)
│   ├── recommend/
│   │   └── v1/
│   │       ├── recommend.proto
│   │       └── recommend_grpc.pb.go
│   ├── user/
│   │   └── v1/
│   │       └── user.proto
│   ├── item/
│   │   └── v1/
│   │       └── item.proto
│   └── ...
│
├── cmd/                          # 服务入口
│   ├── recommend-service/
│   │   └── main.go
│   ├── user-service/
│   │   └── main.go
│   ├── item-service/
│   │   └── main.go
│   └── ...
│
├── internal/                     # 内部代码
│   ├── service/                  # 业务逻辑层
│   │   ├── recommend/
│   │   │   ├── service.go
│   │   │   ├── handler.go
│   │   │   └── fallback.go
│   │   ├── user/
│   │   └── item/
│   │
│   ├── repository/               # 数据访问层
│   │   ├── user_repo.go
│   │   ├── item_repo.go
│   │   ├── event_repo.go
│   │   └── vector_repo.go
│   │
│   ├── model/                    # 数据模型
│   │   ├── user.go
│   │   ├── item.go
│   │   └── event.go
│   │
│   ├── cache/                    # 缓存封装
│   │   ├── redis.go
│   │   └── local.go
│   │
│   ├── inference/                # 推理客户端
│   │   ├── client.go
│   │   └── triton.go
│   │
│   ├── llm/                      # LLM 客户端
│   │   ├── client.go
│   │   ├── openai.go
│   │   └── local.go
│   │
│   └── middleware/               # 中间件
│       ├── auth.go
│       ├── ratelimit.go
│       ├── logging.go
│       └── recovery.go
│
├── pkg/                          # 公共库
│   ├── logger/
│   ├── config/
│   ├── metrics/
│   └── utils/
│
├── configs/                      # 配置文件
│   ├── recommend-service.yaml
│   ├── user-service.yaml
│   └── ...
│
├── deployments/                  # 部署配置
│   ├── kubernetes/
│   │   ├── recommend-service.yaml
│   │   └── ...
│   └── docker/
│       └── Dockerfile
│
├── scripts/                      # 脚本
│   ├── build.sh
│   ├── deploy.sh
│   └── migrate.sh
│
├── tests/                        # 测试
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

### 2.4 中间件设计

#### 2.4.1 认证中间件

```go
// internal/middleware/auth.go
package middleware

import (
    "context"
    "strings"
    
    "github.com/gin-gonic/gin"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

// AuthMiddleware HTTP 认证中间件
func AuthMiddleware(authService AuthService) gin.HandlerFunc {
    return func(c *gin.Context) {
        token := extractToken(c.GetHeader("Authorization"))
        if token == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "missing token"})
            return
        }
        
        claims, err := authService.ValidateToken(c.Request.Context(), token)
        if err != nil {
            c.AbortWithStatusJSON(401, gin.H{"error": "invalid token"})
            return
        }
        
        // 设置用户信息到上下文
        c.Set("user_id", claims.UserID)
        c.Set("claims", claims)
        
        c.Next()
    }
}

// AuthInterceptor gRPC 认证拦截器
func AuthInterceptor(authService AuthService) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 跳过健康检查
        if strings.Contains(info.FullMethod, "Health") {
            return handler(ctx, req)
        }
        
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok {
            return nil, status.Error(codes.Unauthenticated, "missing metadata")
        }
        
        tokens := md.Get("authorization")
        if len(tokens) == 0 {
            return nil, status.Error(codes.Unauthenticated, "missing token")
        }
        
        claims, err := authService.ValidateToken(ctx, tokens[0])
        if err != nil {
            return nil, status.Error(codes.Unauthenticated, "invalid token")
        }
        
        // 将用户信息放入上下文
        ctx = context.WithValue(ctx, "user_id", claims.UserID)
        
        return handler(ctx, req)
    }
}
```

#### 2.4.2 限流中间件

```go
// internal/middleware/ratelimit.go
package middleware

import (
    "net/http"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
    "golang.org/x/time/rate"
)

// RateLimiter 限流器
type RateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
    rate     rate.Limit
    burst    int
}

// NewRateLimiter 创建限流器
func NewRateLimiter(r rate.Limit, b int) *RateLimiter {
    return &RateLimiter{
        limiters: make(map[string]*rate.Limiter),
        rate:     r,
        burst:    b,
    }
}

// getLimiter 获取或创建限流器
func (rl *RateLimiter) getLimiter(key string) *rate.Limiter {
    rl.mu.RLock()
    limiter, exists := rl.limiters[key]
    rl.mu.RUnlock()
    
    if !exists {
        rl.mu.Lock()
        limiter = rate.NewLimiter(rl.rate, rl.burst)
        rl.limiters[key] = limiter
        rl.mu.Unlock()
    }
    
    return limiter
}

// RateLimitMiddleware 限流中间件
func RateLimitMiddleware(rl *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 使用用户 ID 或 IP 作为限流 key
        key := c.GetString("user_id")
        if key == "" {
            key = c.ClientIP()
        }
        
        limiter := rl.getLimiter(key)
        if !limiter.Allow() {
            c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                "error": "rate limit exceeded",
            })
            return
        }
        
        c.Next()
    }
}
```

#### 2.4.3 链路追踪中间件

```go
// internal/middleware/tracing.go
package middleware

import (
    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracingMiddleware 链路追踪中间件
func TracingMiddleware(serviceName string) gin.HandlerFunc {
    tracer := otel.Tracer(serviceName)
    
    return func(c *gin.Context) {
        // 从请求头提取上游 trace context
        ctx := otel.GetTextMapPropagator().Extract(
            c.Request.Context(),
            propagation.HeaderCarrier(c.Request.Header),
        )
        
        // 创建 span
        ctx, span := tracer.Start(ctx, c.FullPath(),
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                attribute.String("http.method", c.Request.Method),
                attribute.String("http.url", c.Request.URL.String()),
                attribute.String("http.user_agent", c.Request.UserAgent()),
            ),
        )
        defer span.End()
        
        // 将 trace context 放入请求上下文
        c.Request = c.Request.WithContext(ctx)
        
        // 继续处理请求
        c.Next()
        
        // 记录响应状态
        span.SetAttributes(
            attribute.Int("http.status_code", c.Writer.Status()),
        )
        
        if len(c.Errors) > 0 {
            span.SetAttributes(attribute.String("error", c.Errors.String()))
        }
    }
}
```

---

## 3. 前端架构设计

### 3.1 前端架构总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         前端架构                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        用户端 (User Portal)                          │   │
│  │  Vue 3 + Vite + Pinia + Vue Router                                   │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │   │
│  │  │  首页   │ │  推荐   │ │  搜索   │ │  详情   │ │  我的   │        │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        管理端 (Admin Portal)                         │   │
│  │  Vue 3 + Ant Design Vue + ECharts                                    │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │   │
│  │  │  仪表盘 │ │  物品   │ │  用户   │ │  策略   │ │  监控   │        │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 用户端设计

#### 3.2.1 目录结构

```
user-portal/
├── src/
│   ├── api/                      # API 接口
│   │   ├── recommend.ts
│   │   ├── user.ts
│   │   ├── item.ts
│   │   └── request.ts           # Axios 封装
│   │
│   ├── components/               # 公共组件
│   │   ├── common/
│   │   │   ├── AppHeader.vue
│   │   │   ├── AppFooter.vue
│   │   │   ├── Loading.vue
│   │   │   └── ErrorBoundary.vue
│   │   │
│   │   ├── recommend/            # 推荐相关组件
│   │   │   ├── RecommendCard.vue
│   │   │   ├── RecommendList.vue
│   │   │   ├── RecommendCarousel.vue
│   │   │   └── RecommendReason.vue
│   │   │
│   │   └── item/                 # 物品相关组件
│   │       ├── ItemCard.vue
│   │       ├── ItemDetail.vue
│   │       └── ItemGrid.vue
│   │
│   ├── composables/              # 组合式函数
│   │   ├── useRecommend.ts
│   │   ├── useUser.ts
│   │   ├── useInfiniteScroll.ts
│   │   └── useTracking.ts
│   │
│   ├── stores/                   # Pinia 状态管理
│   │   ├── recommend.ts
│   │   ├── user.ts
│   │   └── app.ts
│   │
│   ├── views/                    # 页面
│   │   ├── Home.vue
│   │   ├── Recommend.vue
│   │   ├── Search.vue
│   │   ├── ItemDetail.vue
│   │   └── Profile.vue
│   │
│   ├── router/                   # 路由
│   │   └── index.ts
│   │
│   ├── styles/                   # 样式
│   │   ├── variables.scss
│   │   ├── mixins.scss
│   │   └── global.scss
│   │
│   ├── utils/                    # 工具函数
│   │   ├── format.ts
│   │   ├── storage.ts
│   │   └── tracking.ts
│   │
│   ├── App.vue
│   └── main.ts
│
├── public/
├── index.html
├── vite.config.ts
├── tsconfig.json
└── package.json
```

#### 3.2.2 核心组件设计

```vue
<!-- src/components/recommend/RecommendList.vue -->
<template>
  <div class="recommend-list">
    <div class="list-header">
      <h2 class="list-title">{{ title }}</h2>
      <span class="list-subtitle" v-if="subtitle">{{ subtitle }}</span>
    </div>
    
    <div 
      class="list-content"
      ref="listRef"
      @scroll="handleScroll"
    >
      <RecommendCard
        v-for="item in items"
        :key="item.id"
        :item="item"
        @click="handleItemClick(item)"
        @impression="handleImpression(item)"
      />
      
      <div v-if="loading" class="loading-more">
        <LoadingSpinner />
      </div>
      
      <div v-if="noMore" class="no-more">
        没有更多了
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import { useIntersectionObserver } from '@vueuse/core'
import { useRecommendStore } from '@/stores/recommend'
import { useTracking } from '@/composables/useTracking'
import RecommendCard from './RecommendCard.vue'
import LoadingSpinner from '@/components/common/Loading.vue'

interface Props {
  title: string
  subtitle?: string
  sceneId: string
  initialCount?: number
}

const props = withDefaults(defineProps<Props>(), {
  initialCount: 20
})

const emit = defineEmits<{
  (e: 'itemClick', item: RecommendItem): void
}>()

const store = useRecommendStore()
const { trackImpression, trackClick } = useTracking()

const listRef = ref<HTMLElement>()
const items = ref<RecommendItem[]>([])
const loading = ref(false)
const noMore = ref(false)
const page = ref(1)

// 加载推荐数据
async function loadRecommendations() {
  if (loading.value || noMore.value) return
  
  loading.value = true
  try {
    const newItems = await store.fetchRecommendations({
      sceneId: props.sceneId,
      page: page.value,
      count: props.initialCount
    })
    
    if (newItems.length < props.initialCount) {
      noMore.value = true
    }
    
    items.value.push(...newItems)
    page.value++
  } catch (error) {
    console.error('Failed to load recommendations:', error)
  } finally {
    loading.value = false
  }
}

// 无限滚动
function handleScroll(e: Event) {
  const target = e.target as HTMLElement
  const { scrollTop, scrollHeight, clientHeight } = target
  
  if (scrollHeight - scrollTop - clientHeight < 200) {
    loadRecommendations()
  }
}

// 曝光追踪
function handleImpression(item: RecommendItem) {
  trackImpression({
    itemId: item.id,
    sceneId: props.sceneId,
    position: items.value.indexOf(item)
  })
}

// 点击处理
function handleItemClick(item: RecommendItem) {
  trackClick({
    itemId: item.id,
    sceneId: props.sceneId,
    position: items.value.indexOf(item)
  })
  emit('itemClick', item)
}

onMounted(() => {
  loadRecommendations()
})
</script>

<style scoped lang="scss">
.recommend-list {
  display: flex;
  flex-direction: column;
  height: 100%;
  
  .list-header {
    padding: 16px;
    
    .list-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }
    
    .list-subtitle {
      font-size: 14px;
      color: var(--text-secondary);
      margin-top: 4px;
    }
  }
  
  .list-content {
    flex: 1;
    overflow-y: auto;
    padding: 0 16px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 16px;
  }
  
  .loading-more,
  .no-more {
    grid-column: 1 / -1;
    text-align: center;
    padding: 20px;
    color: var(--text-secondary);
  }
}
</style>
```

#### 3.2.3 状态管理设计

```typescript
// src/stores/recommend.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { recommendApi } from '@/api'
import type { RecommendItem, RecommendRequest, RecommendResponse } from '@/types'

export const useRecommendStore = defineStore('recommend', () => {
  // 状态
  const recommendations = ref<Map<string, RecommendItem[]>>(new Map())
  const loading = ref(false)
  const error = ref<string | null>(null)
  const lastRequestId = ref<string | null>(null)
  
  // 计算属性
  const getRecommendations = computed(() => {
    return (sceneId: string) => recommendations.value.get(sceneId) || []
  })
  
  const hasRecommendations = computed(() => {
    return (sceneId: string) => recommendations.value.has(sceneId)
  })
  
  // 操作
  async function fetchRecommendations(request: RecommendRequest): Promise<RecommendItem[]> {
    loading.value = true
    error.value = null
    
    try {
      const response: RecommendResponse = await recommendApi.generate(request)
      
      lastRequestId.value = response.requestId
      
      // 更新状态
      const key = request.sceneId
      const existing = recommendations.value.get(key) || []
      
      if (request.page === 1) {
        recommendations.value.set(key, response.items)
      } else {
        recommendations.value.set(key, [...existing, ...response.items])
      }
      
      return response.items
    } catch (e) {
      error.value = (e as Error).message
      throw e
    } finally {
      loading.value = false
    }
  }
  
  function clearRecommendations(sceneId?: string) {
    if (sceneId) {
      recommendations.value.delete(sceneId)
    } else {
      recommendations.value.clear()
    }
  }
  
  // 预加载下一页
  async function prefetchNextPage(sceneId: string, currentPage: number) {
    const cacheKey = `${sceneId}_${currentPage + 1}`
    if (recommendations.value.has(cacheKey)) return
    
    await fetchRecommendations({
      sceneId,
      page: currentPage + 1,
      count: 20
    })
  }
  
  return {
    // 状态
    recommendations,
    loading,
    error,
    lastRequestId,
    
    // 计算属性
    getRecommendations,
    hasRecommendations,
    
    // 操作
    fetchRecommendations,
    clearRecommendations,
    prefetchNextPage
  }
})
```

### 3.3 管理端设计

#### 3.3.1 目录结构

```
admin-portal/
├── src/
│   ├── api/                      # API 接口
│   │   ├── dashboard.ts
│   │   ├── item.ts
│   │   ├── user.ts
│   │   ├── strategy.ts
│   │   └── monitoring.ts
│   │
│   ├── components/               # 组件
│   │   ├── layout/
│   │   │   ├── AppLayout.vue
│   │   │   ├── Sidebar.vue
│   │   │   └── Header.vue
│   │   │
│   │   ├── dashboard/            # 仪表盘组件
│   │   │   ├── MetricsCard.vue
│   │   │   ├── TrendChart.vue
│   │   │   ├── RealtimeMonitor.vue
│   │   │   └── AlertList.vue
│   │   │
│   │   ├── item/                 # 物品管理组件
│   │   │   ├── ItemTable.vue
│   │   │   ├── ItemForm.vue
│   │   │   └── ItemPreview.vue
│   │   │
│   │   └── strategy/             # 策略管理组件
│   │       ├── StrategyEditor.vue
│   │       ├── ABTestPanel.vue
│   │       └── FeatureFlags.vue
│   │
│   ├── views/                    # 页面
│   │   ├── Dashboard.vue
│   │   ├── ItemManagement.vue
│   │   ├── UserManagement.vue
│   │   ├── StrategyManagement.vue
│   │   └── Monitoring.vue
│   │
│   ├── stores/
│   ├── router/
│   └── utils/
│
├── vite.config.ts
└── package.json
```

#### 3.3.2 仪表盘设计

```vue
<!-- src/views/Dashboard.vue -->
<template>
  <div class="dashboard">
    <!-- 核心指标卡片 -->
    <a-row :gutter="16" class="metrics-row">
      <a-col :span="6" v-for="metric in coreMetrics" :key="metric.key">
        <MetricsCard
          :title="metric.title"
          :value="metric.value"
          :trend="metric.trend"
          :icon="metric.icon"
          :loading="loading"
        />
      </a-col>
    </a-row>
    
    <!-- 图表区域 -->
    <a-row :gutter="16" class="charts-row">
      <a-col :span="16">
        <a-card title="推荐请求趋势" :loading="loading">
          <TrendChart
            :data="requestTrendData"
            :config="requestChartConfig"
          />
        </a-card>
      </a-col>
      <a-col :span="8">
        <a-card title="推荐效果分布" :loading="loading">
          <PieChart
            :data="effectDistribution"
          />
        </a-card>
      </a-col>
    </a-row>
    
    <!-- 实时监控 -->
    <a-row :gutter="16" class="realtime-row">
      <a-col :span="12">
        <a-card title="实时 QPS">
          <RealtimeMonitor
            :data="realtimeQPS"
            :threshold="qpsThreshold"
          />
        </a-card>
      </a-col>
      <a-col :span="12">
        <a-card title="推理延迟 (P99)">
          <RealtimeMonitor
            :data="realtimeLatency"
            :threshold="latencyThreshold"
            unit="ms"
          />
        </a-card>
      </a-col>
    </a-row>
    
    <!-- 告警列表 -->
    <a-card title="最近告警" class="alerts-section">
      <AlertList :alerts="recentAlerts" />
    </a-card>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useDashboardStore } from '@/stores/dashboard'
import MetricsCard from '@/components/dashboard/MetricsCard.vue'
import TrendChart from '@/components/dashboard/TrendChart.vue'
import PieChart from '@/components/dashboard/PieChart.vue'
import RealtimeMonitor from '@/components/dashboard/RealtimeMonitor.vue'
import AlertList from '@/components/dashboard/AlertList.vue'

const store = useDashboardStore()
const loading = ref(true)

const coreMetrics = ref([
  { key: 'qps', title: '当前 QPS', value: 0, trend: 0, icon: 'thunder' },
  { key: 'latency', title: 'P99 延迟', value: 0, trend: 0, icon: 'clock' },
  { key: 'ctr', title: '点击率', value: 0, trend: 0, icon: 'aim' },
  { key: 'coverage', title: '物品覆盖率', value: 0, trend: 0, icon: 'appstore' },
])

const qpsThreshold = { warning: 50000, critical: 80000 }
const latencyThreshold = { warning: 30, critical: 50 }

let refreshInterval: number

async function refreshData() {
  try {
    await store.fetchDashboardData()
    
    // 更新核心指标
    coreMetrics.value = [
      { key: 'qps', title: '当前 QPS', value: store.currentQPS, trend: store.qpsTrend, icon: 'thunder' },
      { key: 'latency', title: 'P99 延迟', value: store.p99Latency, trend: store.latencyTrend, icon: 'clock' },
      { key: 'ctr', title: '点击率', value: (store.ctr * 100).toFixed(2) + '%', trend: store.ctrTrend, icon: 'aim' },
      { key: 'coverage', title: '物品覆盖率', value: (store.coverage * 100).toFixed(1) + '%', trend: 0, icon: 'appstore' },
    ]
    
    loading.value = false
  } catch (error) {
    console.error('Failed to refresh dashboard:', error)
  }
}

onMounted(() => {
  refreshData()
  // 每 5 秒刷新一次
  refreshInterval = setInterval(refreshData, 5000)
})

onUnmounted(() => {
  clearInterval(refreshInterval)
})
</script>
```

---

## 4. 数据库架构设计

### 4.1 数据库分层架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         数据库分层架构                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        缓存层 (Redis Cluster)                        │   │
│  │  用户会话 | 热门物品 | 推荐结果缓存 | 特征缓存 | 实时计数器            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    ↓                                        │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐               │
│  │   PostgreSQL   │  │    Milvus      │  │  ClickHouse    │               │
│  │   (主数据库)    │  │  (向量数据库)   │  │   (OLAP)       │               │
│  │                │  │                │  │                │               │
│  │  用户表        │  │  物品向量      │  │  行为日志      │               │
│  │  物品表        │  │  用户向量      │  │  推荐日志      │               │
│  │  订单表        │  │  语义ID索引    │  │  效果分析      │               │
│  └────────────────┘  └────────────────┘  └────────────────┘               │
│                                    ↓                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        对象存储 (MinIO)                              │   │
│  │  模型文件 | 训练数据 | 多媒体资源 | 日志归档                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 PostgreSQL 表设计

#### 4.2.1 核心表结构

```sql
-- 用户表
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(64) UNIQUE NOT NULL,
    username VARCHAR(128),
    email VARCHAR(256),
    phone VARCHAR(32),
    profile JSONB DEFAULT '{}',
    preferences JSONB DEFAULT '{}',
    embedding vector(256),  -- pgvector
    status SMALLINT DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_active_at TIMESTAMPTZ
);

-- 用户表索引
CREATE INDEX idx_users_email ON users(email) WHERE email IS NOT NULL;
CREATE INDEX idx_users_phone ON users(phone) WHERE phone IS NOT NULL;
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_last_active ON users(last_active_at);
CREATE INDEX idx_users_embedding ON users USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- 物品表
CREATE TABLE items (
    id BIGSERIAL PRIMARY KEY,
    item_id VARCHAR(64) UNIQUE NOT NULL,
    title VARCHAR(512) NOT NULL,
    description TEXT,
    category_path VARCHAR(256),
    category_ids INTEGER[],
    tags VARCHAR(64)[],
    attributes JSONB DEFAULT '{}',
    semantic_ids INTEGER[3],  -- [level1, level2, level3]
    embedding vector(256),
    price DECIMAL(12, 2),
    status SMALLINT DEFAULT 1,  -- 1:active, 0:inactive, -1:deleted
    quality_score FLOAT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 物品表索引
CREATE INDEX idx_items_status ON items(status);
CREATE INDEX idx_items_category ON items USING GIN(category_ids);
CREATE INDEX idx_items_tags ON items USING GIN(tags);
CREATE INDEX idx_items_semantic_l1 ON items((semantic_ids[1]));
CREATE INDEX idx_items_embedding ON items USING ivfflat (embedding vector_cosine_ops) WITH (lists = 1000);
CREATE INDEX idx_items_created ON items(created_at);

-- 用户行为表 (分区表)
CREATE TABLE user_events (
    id BIGSERIAL,
    user_id VARCHAR(64) NOT NULL,
    item_id VARCHAR(64) NOT NULL,
    event_type VARCHAR(32) NOT NULL,  -- click, view, purchase, cart, favorite
    event_value FLOAT,  -- 例如：停留时长、购买金额
    context JSONB DEFAULT '{}',
    request_id VARCHAR(64),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (id, timestamp)
) PARTITION BY RANGE (timestamp);

-- 按月创建分区
CREATE TABLE user_events_2026_01 PARTITION OF user_events
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

CREATE TABLE user_events_2026_02 PARTITION OF user_events
    FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');

-- 用户行为表索引
CREATE INDEX idx_events_user_time ON user_events(user_id, timestamp DESC);
CREATE INDEX idx_events_item_time ON user_events(item_id, timestamp DESC);
CREATE INDEX idx_events_type ON user_events(event_type);

-- 推荐日志表
CREATE TABLE recommendation_logs (
    id BIGSERIAL PRIMARY KEY,
    request_id VARCHAR(64) UNIQUE NOT NULL,
    user_id VARCHAR(64) NOT NULL,
    scene_id VARCHAR(32),
    recommended_items VARCHAR(64)[],
    scores FLOAT[],
    algorithm_version VARCHAR(32),
    model_version VARCHAR(64),
    latency_ms INTEGER,
    is_fallback BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_rec_logs_user ON recommendation_logs(user_id, created_at DESC);
CREATE INDEX idx_rec_logs_time ON recommendation_logs(created_at);

-- 语义 ID 映射表
CREATE TABLE semantic_id_mappings (
    id SERIAL PRIMARY KEY,
    level SMALLINT NOT NULL,  -- 1, 2, 3
    code INTEGER NOT NULL,
    name VARCHAR(256),
    parent_code INTEGER,
    item_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(level, code)
);

CREATE INDEX idx_semantic_parent ON semantic_id_mappings(level, parent_code);

-- A/B 测试配置表
CREATE TABLE ab_tests (
    id SERIAL PRIMARY KEY,
    test_id VARCHAR(64) UNIQUE NOT NULL,
    name VARCHAR(256) NOT NULL,
    description TEXT,
    config JSONB NOT NULL,
    traffic_allocation JSONB NOT NULL,  -- {"control": 0.5, "treatment": 0.5}
    status VARCHAR(32) DEFAULT 'draft',  -- draft, running, paused, completed
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 4.3 Redis 数据结构设计

```yaml
# Redis 数据结构设计

# 1. 用户会话
user:session:{user_id}:
  type: hash
  ttl: 24h
  fields:
    token: "jwt_token"
    device: "mobile"
    last_active: "2026-01-04T10:00:00Z"

# 2. 用户特征缓存
user:features:{user_id}:
  type: hash
  ttl: 1h
  fields:
    profile: "{json}"
    behavior: "{json}"
    realtime: "{json}"

# 3. 推荐结果缓存
rec:result:{user_id}:{scene_id}:
  type: string (json)
  ttl: 5m
  value: "[{item_id, score, reason}, ...]"

# 4. 热门物品
hot:items:{category}:
  type: zset
  ttl: 10m
  members: item_id -> score

# 5. 实时计数器
counter:qps:
  type: string
  ttl: none (定期重置)
  
counter:daily:{date}:impressions:
  type: hyperloglog

# 6. 物品信息缓存
item:info:{item_id}:
  type: hash
  ttl: 30m
  fields:
    title: "..."
    category: "..."
    price: "..."

# 7. 用户行为序列 (最近 N 条)
user:recent:{user_id}:
  type: list
  maxlen: 100
  values: ["{event_json}", ...]

# 8. 分布式锁
lock:user:{user_id}:recommendation:
  type: string
  ttl: 5s
  value: "lock_token"
```

### 4.4 ClickHouse 表设计

```sql
-- 用户行为日志表
CREATE TABLE user_behavior_logs
(
    event_id UUID DEFAULT generateUUIDv4(),
    user_id String,
    item_id String,
    event_type LowCardinality(String),
    event_value Float32,
    context String,  -- JSON
    request_id String,
    timestamp DateTime64(3),
    date Date DEFAULT toDate(timestamp)
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (user_id, timestamp)
TTL timestamp + INTERVAL 180 DAY
SETTINGS index_granularity = 8192;

-- 推荐效果日志表
CREATE TABLE recommendation_effect_logs
(
    request_id String,
    user_id String,
    scene_id LowCardinality(String),
    recommended_items Array(String),
    clicked_items Array(String),
    converted_items Array(String),
    algorithm_version LowCardinality(String),
    model_version String,
    latency_ms UInt32,
    is_fallback UInt8,
    timestamp DateTime64(3),
    date Date DEFAULT toDate(timestamp)
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (user_id, timestamp)
TTL timestamp + INTERVAL 90 DAY;

-- 物化视图：每小时推荐效果汇总
CREATE MATERIALIZED VIEW recommendation_hourly_stats
ENGINE = SummingMergeTree()
PARTITION BY toYYYYMM(hour)
ORDER BY (hour, scene_id, algorithm_version)
AS
SELECT
    toStartOfHour(timestamp) AS hour,
    scene_id,
    algorithm_version,
    count() AS request_count,
    sum(length(clicked_items)) AS click_count,
    sum(length(converted_items)) AS convert_count,
    avg(latency_ms) AS avg_latency,
    quantile(0.99)(latency_ms) AS p99_latency
FROM recommendation_effect_logs
GROUP BY hour, scene_id, algorithm_version;
```

---

## 5. 服务通信设计

### 5.1 服务间通信

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         服务通信架构                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  外部请求 (HTTP/HTTPS)                                                       │
│       │                                                                     │
│       ▼                                                                     │
│  ┌─────────────┐                                                           │
│  │ API Gateway │  ← HTTP (REST API)                                        │
│  └──────┬──────┘                                                           │
│         │                                                                   │
│         ▼                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      服务网格 (Istio)                                │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │                                                             │    │   │
│  │  │  ┌─────────┐  gRPC  ┌─────────┐  gRPC  ┌─────────┐        │    │   │
│  │  │  │ rec-svc │◄──────►│user-svc │◄──────►│item-svc │        │    │   │
│  │  │  └────┬────┘        └────┬────┘        └────┬────┘        │    │   │
│  │  │       │                  │                  │              │    │   │
│  │  │       │  gRPC            │  gRPC           │  gRPC        │    │   │
│  │  │       ▼                  ▼                  ▼              │    │   │
│  │  │  ┌─────────┐        ┌─────────┐        ┌─────────┐        │    │   │
│  │  │  │feat-svc │        │cold-svc │        │ Triton  │        │    │   │
│  │  │  └─────────┘        └─────────┘        └─────────┘        │    │   │
│  │  │                                                             │    │   │
│  │  └─────────────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      异步通信 (Kafka)                                │   │
│  │                                                                     │   │
│  │  Topics:                                                            │   │
│  │  - user_events      (用户行为事件)                                   │   │
│  │  - recommendation_logs (推荐日志)                                    │   │
│  │  - item_updates     (物品更新事件)                                   │   │
│  │  - model_updates    (模型更新通知)                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Protobuf 定义

```protobuf
// api/recommend/v1/recommend.proto
syntax = "proto3";

package recommend.v1;

option go_package = "recommend-system/api/recommend/v1;recommendv1";

service RecommendService {
    // 生成推荐
    rpc Generate(GenerateRequest) returns (GenerateResponse);
    
    // 流式推荐
    rpc StreamGenerate(GenerateRequest) returns (stream RecommendItem);
    
    // 批量推荐
    rpc BatchGenerate(BatchGenerateRequest) returns (BatchGenerateResponse);
    
    // 实时反馈
    rpc Feedback(FeedbackRequest) returns (FeedbackResponse);
}

message GenerateRequest {
    string user_id = 1;
    string scene_id = 2;
    int32 count = 3;
    repeated string context_features = 4;
    map<string, string> extra_params = 5;
}

message GenerateResponse {
    string request_id = 1;
    repeated RecommendItem items = 2;
    ResponseMetadata metadata = 3;
}

message RecommendItem {
    string item_id = 1;
    float score = 2;
    repeated int32 semantic_ids = 3;
    string reason = 4;
    map<string, string> extra_info = 5;
}

message ResponseMetadata {
    string algorithm_version = 1;
    string model_version = 2;
    int32 latency_ms = 3;
    bool is_fallback = 4;
    string trace_id = 5;
}

message BatchGenerateRequest {
    repeated GenerateRequest requests = 1;
}

message BatchGenerateResponse {
    repeated GenerateResponse responses = 1;
}

message FeedbackRequest {
    string request_id = 1;
    string user_id = 2;
    string item_id = 3;
    string feedback_type = 4;  // click, view, purchase, dislike
    float feedback_value = 5;
}

message FeedbackResponse {
    bool success = 1;
}
```

---

## 6. 部署架构设计

### 6.1 Kubernetes 部署架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Kubernetes 集群架构                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Ingress Controller                            │   │
│  │                     (NGINX / Kong Ingress)                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │                      Namespace: recommend-prod                      │    │
│  │                                                                    │    │
│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐               │    │
│  │  │ recommend-svc│ │  user-svc    │ │  item-svc    │               │    │
│  │  │ Deployment   │ │ Deployment   │ │ Deployment   │               │    │
│  │  │ replicas: 10 │ │ replicas: 5  │ │ replicas: 5  │               │    │
│  │  │ HPA: 5-20    │ │ HPA: 3-10    │ │ HPA: 3-10    │               │    │
│  │  └──────────────┘ └──────────────┘ └──────────────┘               │    │
│  │                                                                    │    │
│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐               │    │
│  │  │ feature-svc  │ │coldstart-svc │ │ triton-server│               │    │
│  │  │ Deployment   │ │ Deployment   │ │ Deployment   │               │    │
│  │  │ replicas: 5  │ │ replicas: 3  │ │ replicas: 4  │               │    │
│  │  └──────────────┘ └──────────────┘ └──────────────┘               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │                      Namespace: recommend-data                      │    │
│  │                                                                    │    │
│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐               │    │
│  │  │ PostgreSQL   │ │   Milvus     │ │    Redis     │               │    │
│  │  │ StatefulSet  │ │ StatefulSet  │ │ StatefulSet  │               │    │
│  │  │ replicas: 3  │ │ replicas: 3  │ │ replicas: 6  │               │    │
│  │  └──────────────┘ └──────────────┘ └──────────────┘               │    │
│  │                                                                    │    │
│  │  ┌──────────────┐ ┌──────────────┐                                │    │
│  │  │ ClickHouse   │ │    Kafka     │                                │    │
│  │  │ StatefulSet  │ │ StatefulSet  │                                │    │
│  │  │ replicas: 3  │ │ replicas: 3  │                                │    │
│  │  └──────────────┘ └──────────────┘                                │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │                      Namespace: monitoring                          │    │
│  │                                                                    │    │
│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐               │    │
│  │  │ Prometheus   │ │   Grafana    │ │   Jaeger     │               │    │
│  │  └──────────────┘ └──────────────┘ └──────────────┘               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Kubernetes 资源配置

```yaml
# deployments/kubernetes/recommend-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: recommend-service
  namespace: recommend-prod
  labels:
    app: recommend-service
    version: v1
spec:
  replicas: 10
  selector:
    matchLabels:
      app: recommend-service
  template:
    metadata:
      labels:
        app: recommend-service
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
    spec:
      containers:
        - name: recommend-service
          image: registry.example.com/recommend-service:v1.0.0
          ports:
            - containerPort: 8080
              name: http
            - containerPort: 9090
              name: grpc
            - containerPort: 9091
              name: metrics
          resources:
            requests:
              cpu: "500m"
              memory: "512Mi"
            limits:
              cpu: "2000m"
              memory: "2Gi"
          env:
            - name: CONFIG_PATH
              value: /etc/config/config.yaml
            - name: LOG_LEVEL
              value: info
          volumeMounts:
            - name: config
              mountPath: /etc/config
          livenessProbe:
            httpGet:
              path: /health/live
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health/ready
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
      volumes:
        - name: config
          configMap:
            name: recommend-service-config
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: recommend-service-hpa
  namespace: recommend-prod
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: recommend-service
  minReplicas: 5
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
---
apiVersion: v1
kind: Service
metadata:
  name: recommend-service
  namespace: recommend-prod
spec:
  selector:
    app: recommend-service
  ports:
    - name: http
      port: 80
      targetPort: 8080
    - name: grpc
      port: 9090
      targetPort: 9090
  type: ClusterIP
```

### 6.3 环境配置

| 环境 | 用途 | 集群规模 | 数据库 |
|------|------|----------|--------|
| **dev** | 开发调试 | 3 节点 | 单实例 |
| **staging** | 预发布测试 | 5 节点 | 主从 |
| **prod** | 生产环境 | 20+ 节点 | 高可用集群 |

---

> **文档版本历史**
> - v1.0 (2026-01-04): 初始版本，完整框架设计说明

