# =============================================================================
# Áîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤Â∑•‰ΩúÊµÅ
# 
# Ëß¶ÂèëÊù°‰ª∂: ÂèëÂ∏É release tagÔºåÊàñÊâãÂä®Ëß¶Âèë
# ‰ªªÂä°: ÂÆâÂÖ®Êâ´Êèè„ÄÅÈáë‰∏ùÈõÄÂèëÂ∏É„ÄÅÂÖ®ÈáèÈÉ®ÁΩ≤
# =============================================================================

name: CD - Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Ë¶ÅÈÉ®ÁΩ≤ÁöÑÁâàÊú¨ (‰æãÂ¶Ç: v1.0.0)'
        required: true
      canary_percentage:
        description: 'Èáë‰∏ùÈõÄÊµÅÈáèÁôæÂàÜÊØî (0-100)'
        required: false
        default: '5'
      skip_canary:
        description: 'Ë∑≥ËøáÈáë‰∏ùÈõÄÂèëÂ∏É'
        required: false
        default: 'false'
        type: boolean
      rollback_on_failure:
        description: 'Â§±Ë¥•Êó∂Ëá™Âä®ÂõûÊªö'
        required: false
        default: 'true'
        type: boolean

env:
  REGISTRY: ${{ secrets.DOCKER_REGISTRY_URL }}
  NAMESPACE: recommend-prod
  ENVIRONMENT: production
  PROMETHEUS_URL: http://prometheus.monitoring.svc.cluster.local:9090

# Áîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤ÂøÖÈ°ª‰∏≤Ë°åÊâßË°å
concurrency:
  group: cd-prod
  cancel-in-progress: false

jobs:
  # ==========================================================================
  # ÂáÜÂ§áÈò∂ÊÆµ
  # ==========================================================================
  prepare:
    name: Prepare Production Deployment
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      image_tag: ${{ steps.version.outputs.image_tag }}
      previous_version: ${{ steps.previous.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          
          # ÂéªÊéâ v ÂâçÁºÄËé∑ÂèñÈïúÂÉè tag
          IMAGE_TAG="${VERSION#v}"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION}, image tag: ${IMAGE_TAG}"
      
      - name: Get previous version
        id: previous
        run: |
          PREVIOUS=$(git describe --abbrev=0 --tags HEAD^ 2>/dev/null || echo "none")
          echo "version=${PREVIOUS}" >> $GITHUB_OUTPUT
          echo "Previous version: ${PREVIOUS}"

  # ==========================================================================
  # ÂÆâÂÖ®Êâ´Êèè
  # ==========================================================================
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner (filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './recommend-system'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          ignore-unfixed: true
          format: 'sarif'
          output: 'trivy-fs-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-fs-results.sarif'
      
      - name: Scan Docker images
        run: |
          # Êâ´ÊèèÂç≥Â∞ÜÈÉ®ÁΩ≤ÁöÑÈïúÂÉè
          IMAGES=(
            "recommend-service"
            "user-service"
            "item-service"
            "ugt-inference"
          )
          
          for IMAGE in "${IMAGES[@]}"; do
            echo "Scanning ${{ env.REGISTRY }}/$IMAGE:${{ needs.prepare.outputs.image_tag }}..."
            docker pull ${{ env.REGISTRY }}/$IMAGE:${{ needs.prepare.outputs.image_tag }} || continue
            
            trivy image \
              --severity CRITICAL,HIGH \
              --exit-code 1 \
              --ignore-unfixed \
              ${{ env.REGISTRY }}/$IMAGE:${{ needs.prepare.outputs.image_tag }}
          done
        env:
          TRIVY_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          TRIVY_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Check for known CVEs
        run: |
          echo "Checking dependency vulnerabilities..."
          # Go ‰æùËµñÊ£ÄÊü•
          cd recommend-system
          go list -json -deps ./... | docker run --rm -i sonatypecommunity/nancy:latest sleuth || true

  # ==========================================================================
  # È¢ÑÈÉ®ÁΩ≤È™åËØÅ
  # ==========================================================================
  pre-deploy-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    needs: [prepare, security-scan]
    steps:
      - uses: actions/checkout@v4
      
      - name: Verify images exist
        run: |
          IMAGES=(
            "recommend-service"
            "user-service"
            "item-service"
            "ugt-inference"
          )
          
          for IMAGE in "${IMAGES[@]}"; do
            echo "Verifying ${{ env.REGISTRY }}/$IMAGE:${{ needs.prepare.outputs.image_tag }}..."
            docker manifest inspect ${{ env.REGISTRY }}/$IMAGE:${{ needs.prepare.outputs.image_tag }} > /dev/null
          done
        env:
          DOCKER_CLI_EXPERIMENTAL: enabled
      
      - name: Validate Kubernetes manifests
        run: |
          # ÂÆâË£Ö kubeval
          wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
          tar xf kubeval-linux-amd64.tar.gz
          
          # È™åËØÅ Kubernetes ÈÖçÁΩÆ
          find recommend-system/devops/kubernetes -name "*.yaml" -exec ./kubeval {} \;
      
      - name: Dry-run deployment
        run: |
          echo "Performing dry-run deployment validation..."
          # ËøôÈáåÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§öÁöÑÈ¢ÑÈÉ®ÁΩ≤Ê£ÄÊü•

  # ==========================================================================
  # Èáë‰∏ùÈõÄÈÉ®ÁΩ≤
  # ==========================================================================
  canary-deploy:
    name: Canary Deployment
    runs-on: ubuntu-latest
    needs: [prepare, pre-deploy-validation]
    if: github.event.inputs.skip_canary != 'true'
    environment: production-canary
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
      
      - name: Deploy canary
        run: |
          VERSION="${{ needs.prepare.outputs.image_tag }}"
          CANARY_WEIGHT="${{ github.event.inputs.canary_percentage || '5' }}"
          
          echo "Deploying canary with ${CANARY_WEIGHT}% traffic..."
          
          # Â∫îÁî®Èáë‰∏ùÈõÄÈÖçÁΩÆ
          kubectl apply -f recommend-system/devops/kubernetes/overlays/prod/canary.yaml -n ${{ env.NAMESPACE }}
          
          # Êõ¥Êñ∞Èáë‰∏ùÈõÄ Deployment ÈïúÂÉè
          for SERVICE in recommend-service user-service item-service; do
            kubectl set image deployment/${SERVICE}-canary \
              ${SERVICE}=${{ env.REGISTRY }}/${SERVICE}:${VERSION} \
              -n ${{ env.NAMESPACE }} 2>/dev/null || true
          done
          
          # Á≠âÂæÖÈáë‰∏ùÈõÄÂ∞±Áª™
          kubectl rollout status deployment/recommend-service-canary -n ${{ env.NAMESPACE }} --timeout=5m || true
      
      - name: Wait for canary stabilization
        run: |
          echo "Waiting for canary to stabilize (5 minutes)..."
          sleep 300
      
      - name: Analyze canary metrics
        id: canary-analysis
        run: |
          echo "Analyzing canary metrics..."
          
          # Êü•ËØ¢ Prometheus Ëé∑ÂèñÈáë‰∏ùÈõÄÊåáÊ†á
          # ÈîôËØØÁéá
          ERROR_RATE=$(curl -s "${PROMETHEUS_URL}/api/v1/query" \
            --data-urlencode 'query=sum(rate(http_requests_total{deployment=~".*-canary",status=~"5.."}[5m])) / sum(rate(http_requests_total{deployment=~".*-canary"}[5m]))' \
            | jq -r '.data.result[0].value[1] // "0"')
          
          # P99 Âª∂Ëøü
          LATENCY_P99=$(curl -s "${PROMETHEUS_URL}/api/v1/query" \
            --data-urlencode 'query=histogram_quantile(0.99, sum(rate(http_request_duration_seconds_bucket{deployment=~".*-canary"}[5m])) by (le))' \
            | jq -r '.data.result[0].value[1] // "0"')
          
          echo "Canary Error Rate: $ERROR_RATE"
          echo "Canary P99 Latency: $LATENCY_P99"
          
          # Âà§Êñ≠ÊòØÂê¶ÈÄöËøá
          if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
            echo "error_rate_exceeded=true" >> $GITHUB_OUTPUT
            echo "‚ùå Error rate too high: $ERROR_RATE (threshold: 0.01)"
          else
            echo "error_rate_exceeded=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Error rate acceptable: $ERROR_RATE"
          fi
          
          if (( $(echo "$LATENCY_P99 > 0.5" | bc -l) )); then
            echo "latency_exceeded=true" >> $GITHUB_OUTPUT
            echo "‚ùå Latency too high: ${LATENCY_P99}s (threshold: 0.5s)"
          else
            echo "latency_exceeded=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Latency acceptable: ${LATENCY_P99}s"
          fi
      
      - name: Fail if canary unhealthy
        if: steps.canary-analysis.outputs.error_rate_exceeded == 'true' || steps.canary-analysis.outputs.latency_exceeded == 'true'
        run: |
          echo "Canary deployment failed health checks"
          exit 1

  # ==========================================================================
  # ÂÖ®ÈáèÈÉ®ÁΩ≤
  # ==========================================================================
  full-deploy:
    name: Full Production Deployment
    runs-on: ubuntu-latest
    needs: [prepare, canary-deploy]
    if: always() && (needs.canary-deploy.result == 'success' || github.event.inputs.skip_canary == 'true')
    environment: production
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
      
      - name: Create deployment record
        run: |
          # ËÆ∞ÂΩïÈÉ®ÁΩ≤‰ø°ÊÅØÁî®‰∫éÂõûÊªö
          cat > /tmp/deployment-record.json << EOF
          {
            "version": "${{ needs.prepare.outputs.version }}",
            "previous_version": "${{ needs.prepare.outputs.previous_version }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "actor": "${{ github.actor }}"
          }
          EOF
          
          kubectl create configmap deployment-record \
            --from-file=record.json=/tmp/deployment-record.json \
            -n ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy to production
        id: deploy
        run: |
          VERSION="${{ needs.prepare.outputs.image_tag }}"
          
          echo "Starting full production deployment for version ${VERSION}..."
          
          # ‰ΩøÁî® Kustomize ÈÉ®ÁΩ≤
          cd recommend-system/devops/kubernetes/overlays/prod
          
          # Êõ¥Êñ∞ kustomization ‰∏≠ÁöÑÈïúÂÉèÁâàÊú¨
          kustomize edit set image \
            recommend-service=${{ env.REGISTRY }}/recommend-service:${VERSION} \
            user-service=${{ env.REGISTRY }}/user-service:${VERSION} \
            item-service=${{ env.REGISTRY }}/item-service:${VERSION} \
            ugt-inference=${{ env.REGISTRY }}/ugt-inference:${VERSION}
          
          # Â∫îÁî®ÈÖçÁΩÆ
          kustomize build . | kubectl apply -f - -n ${{ env.NAMESPACE }}
          
          # ÊàñËÄÖÁõ¥Êé•Êõ¥Êñ∞ÈïúÂÉè
          for SERVICE in recommend-service user-service item-service ugt-inference; do
            echo "Updating $SERVICE..."
            kubectl set image deployment/$SERVICE \
              $SERVICE=${{ env.REGISTRY }}/$SERVICE:${VERSION} \
              -n ${{ env.NAMESPACE }}
          done
      
      - name: Wait for rollout
        id: rollout
        run: |
          echo "Waiting for rollout to complete..."
          
          FAILED=false
          for SERVICE in recommend-service user-service item-service ugt-inference; do
            echo "Checking $SERVICE rollout..."
            if ! kubectl rollout status deployment/$SERVICE \
              -n ${{ env.NAMESPACE }} \
              --timeout=10m; then
              echo "$SERVICE rollout failed"
              FAILED=true
            fi
          done
          
          if [ "$FAILED" = true ]; then
            echo "rollout_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "rollout_failed=false" >> $GITHUB_OUTPUT
      
      - name: Remove canary deployments
        if: success()
        run: |
          echo "Removing canary deployments..."
          for SERVICE in recommend-service user-service item-service; do
            kubectl delete deployment ${SERVICE}-canary -n ${{ env.NAMESPACE }} --ignore-not-found
          done
      
      - name: Verify deployment health
        run: |
          echo "Verifying deployment health..."
          sleep 60
          
          # Ê£ÄÊü• Pod Áä∂ÊÄÅ
          UNHEALTHY=$(kubectl get pods -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
          
          if [ -n "$UNHEALTHY" ]; then
            echo "Unhealthy pods found: $UNHEALTHY"
            kubectl describe pods -n ${{ env.NAMESPACE }} $UNHEALTHY
            exit 1
          fi
          
          echo "All pods are healthy"

  # ==========================================================================
  # ÂõûÊªö (Â§±Ë¥•Êó∂)
  # ==========================================================================
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [prepare, full-deploy]
    if: failure() && github.event.inputs.rollback_on_failure != 'false'
    environment: production
    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > $HOME/.kube/config
      
      - name: Perform rollback
        run: |
          echo "Rolling back to previous version..."
          
          for SERVICE in recommend-service user-service item-service ugt-inference; do
            echo "Rolling back $SERVICE..."
            kubectl rollout undo deployment/$SERVICE -n ${{ env.NAMESPACE }}
          done
          
          # Á≠âÂæÖÂõûÊªöÂÆåÊàê
          for SERVICE in recommend-service user-service item-service ugt-inference; do
            kubectl rollout status deployment/$SERVICE \
              -n ${{ env.NAMESPACE }} \
              --timeout=5m || true
          done
      
      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "üîÑ Production Rollback Executed",
              "attachments": [{
                "color": "warning",
                "fields": [
                  {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                  {"title": "Rolled back to", "value": "${{ needs.prepare.outputs.previous_version }}", "short": true},
                  {"title": "Reason", "value": "Deployment failed health checks", "short": false}
                ]
              }]
            }
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ==========================================================================
  # ÈÉ®ÁΩ≤ÂÆåÊàêÈÄöÁü•
  # ==========================================================================
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [prepare, full-deploy]
    if: always()
    steps:
      - name: Notify success
        if: needs.full-deploy.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "‚úÖ Production Deployment Successful",
              "attachments": [{
                "color": "good",
                "fields": [
                  {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                  {"title": "Environment", "value": "Production", "short": true},
                  {"title": "Commit", "value": "${{ github.sha }}", "short": false},
                  {"title": "Actor", "value": "${{ github.actor }}", "short": true}
                ]
              }]
            }
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Notify failure
        if: needs.full-deploy.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "‚ùå Production Deployment Failed",
              "attachments": [{
                "color": "danger",
                "fields": [
                  {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                  {"title": "Environment", "value": "Production", "short": true},
                  {"title": "Action Required", "value": "Please check deployment logs", "short": false}
                ]
              }]
            }
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Create GitHub release notes
        if: needs.full-deploy.result == 'success' && github.event_name == 'release'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: context.payload.release.body + '\n\n---\n\n‚úÖ Successfully deployed to production at ' + new Date().toISOString()
            })

